(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{425:function(a,_,t){"use strict";t.r(_);var e=t(10),s=Object(e.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"mysql-高性能优化规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql-高性能优化规范"}},[a._v("#")]),a._v(" MySQL 高性能优化规范")]),a._v(" "),_("h2",{attrs:{id:"设计规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计规范"}},[a._v("#")]),a._v(" 设计规范")]),a._v(" "),_("h3",{attrs:{id:"_1-设计表的时候-所有表和字段都添加相应的注释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-设计表的时候-所有表和字段都添加相应的注释"}},[a._v("#")]),a._v(" 1. 设计表的时候，所有表和字段都添加相应的注释")]),a._v(" "),_("p",[a._v("这个好习惯一定要养成，设计数据库表的时候，所有表和字段都添加相应的注释，后面更容易维护。")]),a._v(" "),_("h3",{attrs:{id:"_2-如果修改字段含义或对字段表示的状态追加时-需要及时更新字段注释。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-如果修改字段含义或对字段表示的状态追加时-需要及时更新字段注释。"}},[a._v("#")]),a._v(" 2. 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。")]),a._v(" "),_("p",[a._v("这个点，是阿里开发手册中"),_("code",[a._v("Mysql")]),a._v("的规约。你的字段，尤其是表示枚举状态时，如果含义被修改了，或者状态追加时，为了后面更好维护，需要即时更新字段的注释。")]),a._v(" "),_("h2",{attrs:{id:"字段规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字段规范"}},[a._v("#")]),a._v(" 字段规范")]),a._v(" "),_("h3",{attrs:{id:"_1-尽量把所有列定义为-not-null"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-尽量把所有列定义为-not-null"}},[a._v("#")]),a._v(" 1. 尽量把所有列定义为 NOT NULL")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("NOT NULL")]),a._v("列更节省空间："),_("code",[a._v("NULL")]),a._v("列需要一个额外字节作为判断是否为"),_("code",[a._v("NULL")]),a._v("的标志位。")]),a._v(" "),_("li",[_("code",[a._v("NULL")]),a._v("列需要注意空指针问题："),_("code",[a._v("NULL")]),a._v("列在计算和比较的时候，需要注意空指针问题。")])]),a._v(" "),_("h3",{attrs:{id:"_2-同财务相关的金额类数据必须使用-decimal-类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-同财务相关的金额类数据必须使用-decimal-类型"}},[a._v("#")]),a._v(" 2. 同财务相关的金额类数据必须使用 decimal 类型")]),a._v(" "),_("ul",[_("li",[a._v("非精准浮点："),_("code",[a._v("float")]),a._v(","),_("code",[a._v("double")])]),a._v(" "),_("li",[a._v("精准浮点："),_("code",[a._v("decimal")])]),a._v(" "),_("li",[_("code",[a._v("Decimal")]),a._v(" 类型为精准浮点数，在计算时不会丢失精度")])]),a._v(" "),_("p",[a._v("占用空间由定义的宽度决定，每 "),_("code",[a._v("4")]),a._v(" 个字节可以存储 "),_("code",[a._v("9")]),a._v(" 位数字，并且小数点要占用一个字节")]),a._v(" "),_("p",[a._v("可用于存储比 "),_("code",[a._v("bigint")]),a._v(" 更大的整型数据")]),a._v(" "),_("h3",{attrs:{id:"_3-尽量使用-varchar-代替-char"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-尽量使用-varchar-代替-char"}},[a._v("#")]),a._v(" 3. 尽量使用 varchar 代替 char")]),a._v(" "),_("ul",[_("li",[a._v("因为首先变长字段存储空间小，可以节省存储空间。")]),a._v(" "),_("li",[a._v("其次对于查询来说，在一个相对较小的字段内搜索，效率更高。")])]),a._v(" "),_("h2",{attrs:{id:"索引规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引规范"}},[a._v("#")]),a._v(" 索引规范")]),a._v(" "),_("h3",{attrs:{id:"_1-每个-innodb-表必须有个主键"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-每个-innodb-表必须有个主键"}},[a._v("#")]),a._v(" 1. 每个 Innodb 表必须有个主键")]),a._v(" "),_("p",[_("code",[a._v("Innodb")]),a._v("是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。")]),a._v(" "),_("p",[_("code",[a._v("Innodb")]),a._v("是按照主键索引的顺序来组织表的")]),a._v(" "),_("ul",[_("li",[a._v("不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）")]),a._v(" "),_("li",[a._v("不要使用 "),_("code",[a._v("UUID")]),a._v(","),_("code",[a._v("MD5")]),a._v(","),_("code",[a._v("HASH")]),a._v(",字符串列作为主键（无法保证数据的顺序增长）")]),a._v(" "),_("li",[a._v("主键建议使用自增"),_("code",[a._v("ID")]),a._v("值")])]),a._v(" "),_("h3",{attrs:{id:"_2-对于频繁的查询优先考虑使用覆盖索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-对于频繁的查询优先考虑使用覆盖索引"}},[a._v("#")]),a._v(" 2. 对于频繁的查询优先考虑使用覆盖索引")]),a._v(" "),_("p",[a._v("覆盖索引的好处：")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("避免"),_("code",[a._v("Innodb")]),a._v("表进行索引的二次查询（"),_("strong",[a._v("回表")]),a._v("）: "),_("code",[a._v("Innodb")]),a._v(" 是以聚集索引的顺序来存储的，对于 "),_("code",[a._v("Innodb")]),a._v(" 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，\n在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，\n避免了对主键的二次查询 ，减少了 "),_("code",[a._v("IO")]),a._v("操作，提升了查询效率。")])]),a._v(" "),_("li",[_("p",[a._v("可以把随机"),_("code",[a._v("IO")]),a._v("变成顺序"),_("code",[a._v("IO")]),a._v("加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于"),_("code",[a._v("IO")]),a._v("密集型的范围查找来说，\n对比随机从磁盘读取每一行的数据"),_("code",[a._v("IO")]),a._v("要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的"),_("code",[a._v("IO")]),a._v("转变成索引查找的顺序"),_("code",[a._v("IO")]),a._v("。")])])]),a._v(" "),_("h2",{attrs:{id:"开发规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开发规范"}},[a._v("#")]),a._v(" 开发规范")]),a._v(" "),_("h3",{attrs:{id:"_1-避免数据类型的隐式转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-避免数据类型的隐式转换"}},[a._v("#")]),a._v(" 1. 避免数据类型的隐式转换")]),a._v(" "),_("p",[a._v("隐式转换会导致索引失效，如:")]),a._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" name"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("phone "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" customer "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" id "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[a._v("'111'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br")])]),_("h3",{attrs:{id:"_2-where-从句中禁止对列进行函数转换和计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-where-从句中禁止对列进行函数转换和计算"}},[a._v("#")]),a._v(" 2. WHERE 从句中禁止对列进行函数转换和计算")]),a._v(" "),_("p",[a._v("对列进行函数转换或计算时会导致索引失效，如:")]),a._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("date")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("create_time"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[a._v("'20190101'")]),a._v("\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br")])]),_("p",[a._v("推荐：")]),a._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" create_time "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[a._v("'20190101'")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("and")]),a._v(" create_time "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[a._v("'20190102'")]),a._v("\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br")])]),_("h3",{attrs:{id:"_3-禁止使用-select-查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-禁止使用-select-查询"}},[a._v("#")]),a._v(" 3. 禁止使用 SELECT * 查询")]),a._v(" "),_("ul",[_("li",[a._v("消耗更多的"),_("code",[a._v("CPU")]),a._v("和"),_("code",[a._v("IO")]),a._v("以网络带宽资源")]),a._v(" "),_("li",[a._v("无法使用覆盖索引")]),a._v(" "),_("li",[a._v("可减少表结构变更带来的影响")])]),a._v(" "),_("h3",{attrs:{id:"_4-写完-sql-先-explain-查看执行计划"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-写完-sql-先-explain-查看执行计划"}},[a._v("#")]),a._v(" 4. 写完 SQL 先 explain 查看执行计划")]),a._v(" "),_("p",[a._v("日常开发写"),_("code",[a._v("SQL")]),a._v("的时候，尽量养成这个好习惯呀：写完"),_("code",[a._v("SQL")]),a._v("后，用"),_("code",[a._v("explain")]),a._v("分析一下，尤其注意走不走索引。")]),a._v(" "),_("h3",{attrs:{id:"_5-避免使用-join-关联太多的表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-避免使用-join-关联太多的表"}},[a._v("#")]),a._v(" 5. 避免使用 JOIN 关联太多的表")]),a._v(" "),_("p",[a._v("对于 "),_("code",[a._v("MySQL")]),a._v(" 来说，是存在关联缓存的，缓存的大小可以由 "),_("code",[a._v("join_buffer_size")]),a._v(" 参数进行设置。")]),a._v(" "),_("p",[a._v("在 "),_("code",[a._v("MySQL")]),a._v(" 中，对于同一个 "),_("code",[a._v("SQL")]),a._v(" 多关联（"),_("code",[a._v("join")]),a._v("）一个表，就会多分配一个关联缓存，如果在一个 "),_("code",[a._v("SQL")]),a._v(" 中关联的表越多，所占用的内存也就越大。")]),a._v(" "),_("p",[a._v("如果程序中大量的使用了多表关联的操作，同时 "),_("code",[a._v("join_buffer_size")]),a._v(" 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。")]),a._v(" "),_("p",[a._v("同时对于关联操作来说，会产生临时表操作，影响查询效率，"),_("strong",[_("code",[a._v("MySQL")]),a._v(" 最多允许关联 "),_("code",[a._v("61")]),a._v(" 个表，建议不超过 "),_("code",[a._v("5")]),a._v(" 个")]),a._v("。")]),a._v(" "),_("h3",{attrs:{id:"_6-拆分复杂的大-sql-为多个小-sql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-拆分复杂的大-sql-为多个小-sql"}},[a._v("#")]),a._v(" 6. 拆分复杂的大 SQL 为多个小 SQL")]),a._v(" "),_("ul",[_("li",[a._v("大 "),_("code",[a._v("SQL")]),a._v(" 逻辑上比较复杂，需要占用大量 "),_("code",[a._v("CPU")]),a._v(" 进行计算")]),a._v(" "),_("li",[_("code",[a._v("MySQL")]),a._v(" 中，一个 "),_("code",[a._v("SQL")]),a._v(" 只能使用一个 "),_("code",[a._v("CPU")]),a._v(" 进行计算")]),a._v(" "),_("li",[_("code",[a._v("SQL")]),a._v(" 拆分后可以通过并行执行来提高处理效率")])]),a._v(" "),_("h2",{attrs:{id:"操作规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作规范"}},[a._v("#")]),a._v(" 操作规范")]),a._v(" "),_("h3",{attrs:{id:"_1-对于大表使用-pt-online-schema-change-修改表结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-对于大表使用-pt-online-schema-change-修改表结构"}},[a._v("#")]),a._v(" 1. 对于大表使用 pt-online-schema-change 修改表结构")]),a._v(" "),_("ul",[_("li",[a._v("避免大表修改产生的主从延迟")]),a._v(" "),_("li",[a._v("避免在对表字段进行修改时进行锁表")])]),a._v(" "),_("p",[a._v("对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。")]),a._v(" "),_("p",[_("code",[a._v("pt-online-schema-change")]),a._v("它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，\n并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。\n把原来一个 "),_("code",[a._v("DDL")]),a._v(" 操作，分解成多个小的批次进行。")]),a._v(" "),_("h2",{attrs:{id:"limit-深分页问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#limit-深分页问题"}},[a._v("#")]),a._v(" limit 深分页问题 👍")]),a._v(" "),_("p",[a._v("举例：")]),a._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("select")]),a._v(" id"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("name"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("balance "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" account "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" create_time"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[a._v("'2020-09-19'")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("limit")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("100000")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br")])]),_("p",[a._v("limit深分页，导致SQL变慢原因有两个：")]),a._v(" "),_("ol",[_("li",[a._v("limit语句会先扫描"),_("code",[a._v("offset+n")]),a._v("行，然后再丢弃掉前"),_("code",[a._v("offset")]),a._v("行，返回后n行数据。也就是说limit 100000,10，就会扫描100010行，而limit 0,10，只扫描10行。")]),a._v(" "),_("li",[a._v("limit 100000,10 扫描更多的行数，也意味着回表更多的次数。")])]),a._v(" "),_("p",[a._v("优化深分页问题我们可以通过"),_("strong",[a._v("减少回表次数")]),a._v("来优化。一般有"),_("strong",[a._v("标签记录法")]),a._v("和"),_("strong",[a._v("延迟关联法")]),a._v("：")]),a._v(" "),_("ul",[_("li",[a._v("标签记录法："),_("code",[a._v("select id,name,balance FROM account where id > 100000 limit 10;")]),a._v(" 需要一种类似连续自增的字段来支持")]),a._v(" "),_("li",[a._v("延迟关联法："),_("code",[a._v("select acct1.id,acct1.name,acct1.balance FROM account acct1 INNER JOIN (SELECT a.id FROM account a WHERE a.create_time > '2020-09-19' limit 100000, 10) AS acct2 on acct1.id= acct2.id;")]),a._v("\n优化思路：先通过idx_create_time二级索引树查询到满足条件的主键ID，再与原表通过主键ID内连接，这样后面直接走了主键索引了，同时也减少了回表")])])])}),[],!1,null,null,null);_.default=s.exports}}]);