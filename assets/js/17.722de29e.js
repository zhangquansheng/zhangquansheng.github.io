(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{285:function(t,v,_){"use strict";_.r(v);var a=_(10),l=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"算法思维"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法思维"}},[t._v("#")]),t._v(" 算法思维 🔨")]),t._v(" "),v("ul",[v("li",[t._v("双指针\n"),v("ul",[v("li",[t._v("「快慢指针」: 主要解决链表中的问题，比如典型的判定链表中是否包含环；")]),t._v(" "),v("li",[t._v("「左右指针」: 主要解决数组（或者字符串）中的问题，比如二分查找。")])])]),t._v(" "),v("li",[t._v("滑动窗口")]),t._v(" "),v("li",[t._v("递归")]),t._v(" "),v("li",[t._v("DP（动态规划）")])]),t._v(" "),v("h2",{attrs:{id:"双指针-快慢指针-判断链表是否有环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双指针-快慢指针-判断链表是否有环"}},[t._v("#")]),t._v(" 双指针（快慢指针）判断链表是否有环")]),t._v(" "),v("ol",[v("li",[t._v("建立一个快指针一个慢指针，快指针一次走两步，慢指针一次走一步")]),t._v(" "),v("li",[t._v("如果结构是环形的，那么他们肯定会相遇（相遇的点）")]),t._v(" "),v("li",[t._v("如果结构不是环形，毫无疑问"),v("strong",[t._v("快指针")]),t._v("将会先到达终点！也就是链表的出口（next=null）")])]),t._v(" "),v("h3",{attrs:{id:"判断环路长度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#判断环路长度"}},[t._v("#")]),t._v(" 判断环路长度")]),t._v(" "),v("ol",[v("li",[t._v("同上，先找到他们相遇的点")]),t._v(" "),v("li",[t._v("慢指针不动，进行第二次迭代，快指针一次走一步，当他们再次相遇的时候就是环路的长度")])]),t._v(" "),v("h3",{attrs:{id:"判断环路的起点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#判断环路的起点"}},[t._v("#")]),t._v(" 判断环路的起点")]),t._v(" "),v("ol",[v("li",[t._v("先找到它们第一次相遇的点。此时快慢指针指向相同的位置。")]),t._v(" "),v("li",[t._v("慢指针不动，"),v("strong",[t._v("快指针返回起点")])]),t._v(" "),v("li",[t._v("进行第二次迭代，快指针、慢指针一次走一步，当它们再次相遇时，此时的结点即是"),v("strong",[t._v("环路的起点")]),t._v("。")])])])}),[],!1,null,null,null);v.default=l.exports}}]);