(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{381:function(t,a,s){"use strict";s.r(a);var v=s(10),e=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"抽象类-vs-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类-vs-接口"}},[t._v("#")]),t._v(" 抽象类 VS 接口")]),t._v(" "),a("p",[a("strong",[t._v("关注对象的本质时用抽象类，关注一个对象的功能时用接口。（抽象类是关注类的属性，接口是关注类的行为）")])]),t._v(" "),a("blockquote",[a("p",[t._v("举例：飞机和鸟，飞机的各个类型和鸟的各个类型需要通过分别继承飞机和鸟实现，而他们的公共特点飞行，是他们共同的行为，需要定义为接口，使得他们均能够实现。")])]),t._v(" "),a("h2",{attrs:{id:"抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),a("ol",[a("li",[t._v("抽象类不能被实例化，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。")]),t._v(" "),a("li",[t._v("抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。")]),t._v(" "),a("li",[t._v("抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。")]),t._v(" "),a("li",[t._v("构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。")]),t._v(" "),a("li",[t._v("抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。")]),t._v(" "),a("li",[a("code",[t._v("abstract")]),t._v("不能与"),a("code",[t._v("final")]),t._v("并列修饰同一个类，因为抽象类是要被继承的（同4）。")]),t._v(" "),a("li",[a("code",[t._v("abstract")]),t._v("不能与"),a("code",[t._v("private")]),t._v("、"),a("code",[t._v("static")]),t._v("、"),a("code",[t._v("final")]),t._v("或"),a("code",[t._v("native")]),t._v("并列修饰同一个方法，因为抽象方法需要在子类中被具体实现（同5）。")])]),t._v(" "),a("h2",{attrs:{id:"接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),a("ol",[a("li",[t._v("接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 "),a("code",[t._v("public abstract")]),t._v("（"),a("strong",[a("code",[t._v("JAVA8")]),t._v("的新特性：接口声明可以包含"),a("code",[t._v("default")]),t._v("、"),a("code",[t._v("static")])]),t._v("）")]),t._v(" "),a("li",[t._v("接口中可以含有变量，但是接口中的变量会被隐式的指定为"),a("code",[t._v("public static final")]),t._v("变量（并且只能是"),a("code",[t._v("public")]),t._v("，用"),a("code",[t._v("private")]),t._v("修饰会报编译错误）。")]),t._v(" "),a("li",[t._v("接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。")])]),t._v(" "),a("h2",{attrs:{id:"抽象类和接口的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类和接口的区别"}},[t._v("#")]),t._v(" 抽象类和接口的区别")]),t._v(" "),a("blockquote",[a("p",[t._v("请注意"),a("code",[t._v("JAVA8")]),t._v("与"),a("code",[t._v("JAVA7")]),t._v("版本之间的区别")])]),t._v(" "),a("ol",[a("li",[t._v("抽象类中的方法可以有方法体，就是能实现方法的具体功能，"),a("s",[t._v("但是接口中的方法不行")]),t._v("。")]),t._v(" "),a("li",[t._v("抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是"),a("code",[t._v("public static final")]),t._v("类型的。")]),t._v(" "),a("li",[a("s",[t._v("接口中不能含有静态代码块以及静态方法(用"),a("code",[t._v("static")]),t._v("修饰的方法)")]),t._v("，而抽象类是可以有静态代码块和静态方法。")]),t._v(" "),a("li",[a("strong",[t._v("一个类只能继承一个抽象类，而一个类却可以实现多个接口")]),t._v("。")])]),t._v(" "),a("h2",{attrs:{id:"java-8-引入了新的语言特性-默认方法-default-methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-8-引入了新的语言特性-默认方法-default-methods"}},[t._v("#")]),t._v(" Java 8 引入了新的语言特性——默认方法（Default Methods）")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("multiply")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("在上面的 Math 接口中，我们添加了一个与实际方法体相乘的方法。")]),t._v(" "),a("h3",{attrs:{id:"为什么我们需要默认方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么我们需要默认方法"}},[t._v("#")]),t._v(" 为什么我们需要默认方法？")]),t._v(" "),a("p",[t._v("为什么要在接口中添加方法？我们会这样做是"),a("strong",[t._v("因为接口与其实现类耦合得太紧密了")]),t._v("。即不可能在不破坏实现类的情况下在接口中添加方法。一旦你在接口中添加了一个方法，它的所有实现类都必须声明这个新方法的方法体。")]),t._v(" "),a("p",[t._v("从 "),a("code",[t._v("Java 8")]),t._v(" 开始，事情开始变得丑陋。引入了一个很酷的新功能"),a("code",[t._v("Lambda")]),t._v("。但是，无法在现有 "),a("code",[t._v("Java")]),t._v(" 库（例如 "),a("code",[t._v("java.util")]),t._v(" 包）中使用此功能。如果你在 "),a("code",[t._v("interface")]),t._v(" 中添加一个方法"),a("code",[t._v("List")]),t._v("，它会破坏一切。\n您需要在每个实现List接口的类中添加它的实现。想象一下在现实世界中有多少自定义类会发生变化。")]),t._v(" "),a("p",[t._v("所以为了"),a("strong",[t._v("向后兼容")]),t._v("，"),a("code",[t._v("Java 8")]),t._v(" 巧妙地添加了"),a("code",[t._v("Default Methods")]),t._v("。")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Default Methods"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.viralpatel.net/java-8-default-methods-tutorial/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java 8 Default Methods Tutorial"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=e.exports}}]);