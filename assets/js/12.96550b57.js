(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{284:function(v,_,t){"use strict";t.r(_);var l=t(10),s=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[v._v("#")]),v._v(" 限流")]),v._v(" "),_("p",[v._v("针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。")]),v._v(" "),_("h2",{attrs:{id:"常见限流算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见限流算法"}},[v._v("#")]),v._v(" 常见限流算法")]),v._v(" "),_("ul",[_("li",[v._v("一、 "),_("strong",[v._v("漏桶算法")]),v._v(" "),_("ol",[_("li",[v._v("往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。")]),v._v(" "),_("li",[v._v("总量控制，桶大小是设计的关键")]),v._v(" "),_("li",[v._v("应用场景：瞬时高并发"),_("strong",[v._v("流量")]),v._v("，例如0点签到，整点秒杀")])])]),v._v(" "),_("li",[v._v("二、 "),_("strong",[v._v("令牌桶算法")]),v._v(" "),_("ol",[_("li",[v._v("桶里装的是令牌，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。")]),v._v(" "),_("li",[v._v("添加令牌的速率是设计的关键")]),v._v(" "),_("li",[v._v("应用场景：控制自己的处理"),_("strong",[v._v("速度")]),v._v("，防止过载")])])]),v._v(" "),_("li",[v._v("三、 "),_("strong",[v._v("滑动窗口计数器算法")]),v._v(" "),_("ol",[_("li",[v._v("滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确")]),v._v(" "),_("li",[v._v("Sentinel 是基于滑动窗口实现的")])])]),v._v(" "),_("li",[v._v("四、固定窗口计数器算法（这种限流算法无法保证限流速率，因而无法保证突然激增的流量，不推荐。）")])]),v._v(" "),_("h2",{attrs:{id:"漏桶和令牌桶算法差别及适用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#漏桶和令牌桶算法差别及适用场景"}},[v._v("#")]),v._v(" 漏桶和令牌桶算法差别及适用场景")]),v._v(" "),_("ol",[_("li",[v._v("漏桶关注的量，令牌桶关注的是速率")])])])}),[],!1,null,null,null);_.default=s.exports}}]);