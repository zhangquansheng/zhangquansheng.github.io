(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{478:function(t,v,_){"use strict";_.r(v);var a=_(10),c=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"watch-机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watch-机制"}},[t._v("#")]),t._v(" Watch 机制 🔨")]),t._v(" "),v("p",[v("code",[t._v("Watch")]),t._v("（事件监听器），是"),v("code",[t._v("Zookeeper")]),t._v("中的一个很重要的特性。"),v("code",[t._v("Zookeeper")]),t._v("允许用户在指定节点上注册一些"),v("code",[t._v("Watch")]),t._v("，并且在一些特定事件触发的时候，"),v("code",[t._v("ZooKeeper")]),t._v("服务端会将事件通知到感兴趣的客户端上去，"),v("strong",[t._v("该机制是Zookeeper实现分布式协调服务的重要特性")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"watch-特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watch-特性"}},[t._v("#")]),t._v(" Watch 特性")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("主动推送")]),t._v("："),v("code",[t._v("Watch")]),t._v("被触发时，由"),v("code",[t._v("Zookeeper")]),t._v("服务器主动将更新推送（"),v("code",[t._v("PUSH")]),t._v("）给客户端，而不需要客户端轮询。")]),t._v(" "),v("li",[v("strong",[t._v("一次性")]),t._v("：　数据变化时，Watch 只会被触发一次。如果客户端想得到后续更新的通知，必须要在"),v("code",[t._v("Watch")]),t._v("被触发后重新注册一个"),v("code",[t._v("Watch")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("可见性")]),t._v("：　如果一个客户端在读请求中附带"),v("code",[t._v("Watch")]),t._v("，"),v("code",[t._v("Watch")]),t._v("被触发的同时再次读取数据，客户端在得到"),v("code",[t._v("Watch")]),t._v("消息之前肯定不可能看到更新后的数据。换句话说，更新通知先于更新结果。")]),t._v(" "),v("li",[v("strong",[t._v("顺序性")]),t._v("：　如果多个更新触发了多个"),v("code",[t._v("Watch")]),t._v("，那"),v("code",[t._v("Watch")]),t._v("被触发的顺序与更新顺序一致。")])]),t._v(" "),v("h2",{attrs:{id:"watch-架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watch-架构"}},[t._v("#")]),t._v(" Watch 架构")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/zk/watch.png",alt:"Watch架构"}})])])}),[],!1,null,null,null);v.default=c.exports}}]);