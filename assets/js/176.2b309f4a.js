(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{442:function(v,_,t){"use strict";t.r(_);var r=t(10),s=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"消息队列基础问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列基础问题"}},[v._v("#")]),v._v(" 消息队列基础问题")]),v._v(" "),_("h2",{attrs:{id:"为什么要用消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用消息队列"}},[v._v("#")]),v._v(" 为什么要用消息队列")]),v._v(" "),_("p",[v._v("结合自己的项目，说明使用消息队列能为我们的系统带来下面三点好处：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("通过异步处理提高系统性能（减少响应所需时间）")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("降低系统耦合性")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("削峰/限流")])])]),v._v(" "),_("p",[v._v("当然，使用消息队列带来的一些问题")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("系统复杂性提高了")]),v._v("： 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！")]),v._v(" "),_("li",[_("strong",[v._v("一致性问题")]),v._v("：万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!")]),v._v(" "),_("li",[_("strong",[v._v("系统可用性降低")]),v._v("：考虑消息丢失或者说 MQ 挂掉等等的情况")])]),v._v(" "),_("h2",{attrs:{id:"消息堆积问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息堆积问题"}},[v._v("#")]),v._v(" 消息堆积问题 🎉")]),v._v(" "),_("p",[v._v("产生消息堆积的根源其实就只有两个："),_("strong",[v._v("生产者生产太快")]),v._v("或者"),_("strong",[v._v("消费者消费太慢")]),v._v("。")]),v._v(" "),_("ol",[_("li",[v._v("因为生产者生产太快，我们可以使用一些"),_("strong",[v._v("限流降级")]),v._v("的方法")]),v._v(" "),_("li",[v._v("消费者消费过慢的话，我们可以先检查：\n"),_("ol",[_("li",[v._v("是否是消费者出现了大量的消费错误，打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。")]),v._v(" "),_("li",[v._v("当然，最快速解决消息堆积问题的方法还是"),_("strong",[v._v("增加消费者实例")]),v._v("，不过 同时你还需要"),_("strong",[v._v("增加每个主题的队列数量")])])])])]),v._v(" "),_("p",[v._v("消息堆积的处理策略整体上说就是"),_("strong",[v._v("生产者producer限流")]),v._v("，"),_("strong",[v._v("RocketMQ扩容")]),v._v("，"),_("strong",[v._v("增加消费者consumer（同时也要增加"),_("code",[v._v("topic")]),v._v("的队列数量）")])])])}),[],!1,null,null,null);_.default=s.exports}}]);