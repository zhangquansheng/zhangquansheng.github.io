(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{420:function(_,v,t){"use strict";t.r(v);var o=t(10),e=Object(o.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[_._v("#")]),_._v(" 事务")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://dev.mysql.com/doc/refman/5.7/en/mysql-acid.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("官方文档"),v("OutboundLink")],1)]),_._v(" "),v("h2",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[_._v("#")]),_._v(" 概述")]),_._v(" "),v("p",[_._v("数据库"),v("strong",[_._v("事务")]),_._v("是访问并可能操作各种数据项的一个数据库操作序列，这些操作"),v("strong",[_._v("要么全部执行,要么全部不执行")]),_._v("，是一个不可分割的工作单位。")]),_._v(" "),v("p",[_._v("一般来说，数据库事务具有"),v("strong",[_._v("ACID")]),_._v("这4个"),v("strong",[_._v("特性")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("原子性（Atomicity）：")]),_._v("  一个事务（"),v("code",[_._v("transaction")]),_._v("）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（"),v("code",[_._v("Rollback")]),_._v("）到事务开始前的状态，就像这个事务从来没有执行过一样。")]),_._v(" "),v("li",[v("strong",[_._v("一致性（Consistency）：")]),_._v("  在事务开始之前和事务结束以后，数据库的完整性没有被破坏。")]),_._v(" "),v("li",[v("strong",[_._v("隔离性（Isolation）：")]),_._v("  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（"),v("code",[_._v("Read uncommitted")]),_._v("）、读提交（"),v("code",[_._v("read committed")]),_._v("）、可重复读（"),v("code",[_._v("repeatable read")]),_._v("）和串行化（"),v("code",[_._v("Serializable")]),_._v("）。")]),_._v(" "),v("li",[v("strong",[_._v("持久性（Durability）:")]),_._v("  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。")])]),_._v(" "),v("p",[_._v("数据库"),v("strong",[_._v("事务")]),_._v("是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以了。在"),v("code",[_._v("MySQL")]),_._v("中只有使用了"),v("code",[_._v("Innodb")]),_._v("数据库引擎的数据库表才支持事务。")]),_._v(" "),v("h2",{attrs:{id:"事务的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的实现"}},[_._v("#")]),_._v(" 事务的实现")]),_._v(" "),v("p",[_._v("事务隔离性是"),v("strong",[_._v("锁")]),_._v("来实现的， "),v("code",[_._v("redo log")]),_._v("（重做日志）用来保证事务的"),v("strong",[_._v("原子性和持久性")]),_._v("，"),v("code",[_._v("undo log")]),_._v("用来保证事务的"),v("strong",[_._v("一致性")]),_._v("。")]),_._v(" "),v("p",[_._v("或许有人认为"),v("code",[_._v("redo")]),_._v("是"),v("code",[_._v("undo")]),_._v("的逆过程，其实不对的。"),v("code",[_._v("redo")]),_._v("和"),v("code",[_._v("undo")]),_._v("的作用都可以看做是一种恢复操作，"),v("code",[_._v("redo")]),_._v("恢复提交事务修改的页，而"),v("code",[_._v("undo")]),_._v("回滚行记录。因此两者记录的内容不同，"),v("code",[_._v("redo")]),_._v("通常是物理日志，记录的是页的物理修改操作，"),v("code",[_._v("undo")]),_._v("是逻辑日志，根据每行记录进行记录。")]),_._v(" "),v("h3",{attrs:{id:"redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[_._v("#")]),_._v(" Redo Log")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("官方文档"),v("OutboundLink")],1)]),_._v(" "),v("h4",{attrs:{id:"_1-基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本概念"}},[_._v("#")]),_._v(" 1. 基本概念")]),_._v(" "),v("p",[v("code",[_._v("redo log")]),_._v("包括两部分：一是内存中的日志缓冲("),v("code",[_._v("redo log buffer")]),_._v(")，其易失性的；二是磁盘上的重做日志文件("),v("code",[_._v("redo log file")]),_._v(")，其是持久的。")]),_._v(" "),v("p",[v("code",[_._v("InnoDB")]),_._v("是事务的存储引擎，在概念上，其通过"),v("strong",[_._v("Force Log at Commit")]),_._v("机制实现事务的持久性，即在事务提交（COMMIT）时，必须先将该事务的所有事务日志写入到磁盘上的"),v("code",[_._v("redo log file")]),_._v("和"),v("code",[_._v("undo log file")]),_._v("中进行持久化，待事务的"),v("code",[_._v("COMMIT")]),_._v("操作完成才算完成。")]),_._v(" "),v("p",[_._v("为了确保每次日志都能写入到事务日志文件中，在每次将日志缓冲("),v("code",[_._v("redo log buffer")]),_._v(")写入重做日志文件("),v("code",[_._v("redo log file")]),_._v(")之后，"),v("code",[_._v("InnoDB")]),_._v("存储引擎都需要调用一次"),v("code",[_._v("fsync")]),_._v("操作(即fsync()系统调用)。\n之所以要经过一层"),v("code",[_._v("os buffer")]),_._v("，是因为"),v("code",[_._v("open")]),_._v("日志文件的时候，"),v("code",[_._v("open")]),_._v("没有使用"),v("strong",[_._v("O_DIRECT")]),_._v("标志位，该标志位意味着绕过操作系统层的"),v("code",[_._v("os buffer")]),_._v("，"),v("code",[_._v("IO")]),_._v("直写到底层存储设备。\n不使用该标志位意味着将日志进行缓冲，缓冲到了一定容量或者显式调用"),v("code",[_._v("fsync()")]),_._v("才会将缓冲中的日志刷到存储设备。如果使用该标志位，则意味着每次都要发起系统调用。")]),_._v(" "),v("p",[v("img",{attrs:{src:"/img/mysql/fsync.png",alt:"fsync"}})]),_._v(" "),v("p",[v("code",[_._v("InnoDB")]),_._v("存储引擎允许用户手工设置非持久性的情况发生，以此提高数据库的性能。既当事务提交时，日志不写入事务日志文件，而是等待一个时间周期后再执行"),v("code",[_._v("fsync")]),_._v("操作。\n由于并非强制在事务提交时进行一次"),v("code",[_._v("fsync")]),_._v("操作，显然这可以显著提高数据库的性能，但当数据库发生宕机时，由于部分日志未刷新到磁盘，因此会丢失最后一段时间的事务。")]),_._v(" "),v("p",[_._v("参数"),v("code",[_._v("innodb_flush_log_at_trx_commit")]),_._v("用来控制重做日志刷新到磁盘的策略，该参数的默认值为"),v("strong",[_._v("1")]),_._v("。可以通过命令查看此参数的设置：")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("select")]),_._v(" @"),v("span",{pre:!0,attrs:{class:"token variable"}},[_._v("@innodb_flush_log_at_trx_commit")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("其中参数值含义如下：")]),_._v(" "),v("ul",[v("li",[_._v("1  表示事务提交时必须调用一次"),v("code",[_._v("fsync")]),_._v("操作；")]),_._v(" "),v("li",[_._v("0  表示事务提交时不进行写入"),v("code",[_._v("redo")]),_._v("日志操作，这个操作仅在 "),v("code",[_._v("master thread")]),_._v(" 中完成，而在 "),v("code",[_._v("master thread")]),_._v(" 中每"),v("code",[_._v("1秒")]),_._v("会进行一次"),v("code",[_._v("redo")]),_._v("日志文件的"),v("code",[_._v("fsync")]),_._v("操作；")]),_._v(" "),v("li",[_._v("2  表示事务提交时把"),v("code",[_._v("redo")]),_._v("日志写入磁盘文件对应的文件系统的缓存中，不进行"),v("code",[_._v("fsync")]),_._v("操作；\n"),v("img",{attrs:{src:"/img/mysql/innodb_flush_log_at_trx_commit.png",alt:"innodb_flush_log_at_trx_commit"}})])]),_._v(" "),v("h4",{attrs:{id:"_2-日志块-log-block"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-日志块-log-block"}},[_._v("#")]),_._v(" 2. 日志块(log block)")]),_._v(" "),v("p",[v("code",[_._v("InnoDB")]),_._v("存储引擎中，"),v("code",[_._v("redo log")]),_._v("以块为单位进行存储的，每个块占512字节，这称为"),v("code",[_._v("redo log block")]),_._v("。")]),_._v(" "),v("h4",{attrs:{id:"_3-log-group-和-redo-log-file"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-log-group-和-redo-log-file"}},[_._v("#")]),_._v(" 3. log group 和 redo log file")]),_._v(" "),v("p",[v("code",[_._v("log group")]),_._v(" 是逻辑上的概念，并没有一个实际存储的物理文件来表示"),v("code",[_._v("log group")]),_._v("信息。"),v("code",[_._v("log group")]),_._v("表示的是"),v("code",[_._v("redo log group")]),_._v("，一个组内由多个大小完全相同的"),v("code",[_._v("redo log file")]),_._v("组成。")]),_._v(" "),v("h4",{attrs:{id:"_4-redo-log-格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-redo-log-格式"}},[_._v("#")]),_._v(" 4. redo log 格式")]),_._v(" "),v("p",[_._v("由于"),v("code",[_._v("InnoDB")]),_._v("存储引擎的存储管理是基于页的，故其"),v("code",[_._v("redo log")]),_._v("也是基于页的。")]),_._v(" "),v("h4",{attrs:{id:"_5-lsn"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-lsn"}},[_._v("#")]),_._v(" 5. LSN")]),_._v(" "),v("p",[v("strong",[_._v("LSN")]),_._v("称为日志序列号(Log Sequence Number)。在"),v("code",[_._v("InnoDB")]),_._v("存储引擎中，"),v("strong",[_._v("LSN")]),_._v("占用8个字节，并且单调递增。"),v("strong",[_._v("LSN")]),_._v("表示的含义有：")]),_._v(" "),v("ul",[v("li",[_._v("重做日志写入的总量，通过LSN开始号码和结束号码可以计算出写入的日志量")]),_._v(" "),v("li",[_._v("checkpoint（检查点） 的位置")]),_._v(" "),v("li",[_._v("页的版本")])]),_._v(" "),v("h4",{attrs:{id:"_6-redo-log-总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-redo-log-总结"}},[_._v("#")]),_._v(" 6. Redo Log 总结 🎉")]),_._v(" "),v("ol",[v("li",[_._v("是 Innodb 存储引擎层生成的日志，实现了事务的"),v("strong",[_._v("持久性")])]),_._v(" "),v("li",[_._v("将写操作从磁盘的「随机写」变成了「顺序写」，提升"),v("code",[_._v("MySQL")]),_._v("写入磁盘的性能。")]),_._v(" "),v("li",[v("strong",[_._v("WAL")]),_._v(" （Write-Ahead Logging）技术，指的是 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志（Redo Log）上，然后在合适的时间再更新到磁盘上。")])]),_._v(" "),v("h3",{attrs:{id:"undo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[_._v("#")]),_._v(" Undo Log")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-logs.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("官方文档"),v("OutboundLink")],1)]),_._v(" "),v("h4",{attrs:{id:"_1-基本概念-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本概念-2"}},[_._v("#")]),_._v(" 1. 基本概念")]),_._v(" "),v("p",[v("strong",[v("code",[_._v("undo log")]),_._v("有两个作用：提供"),v("code",[_._v("回滚")]),_._v("和"),v("code",[_._v("MVCC")]),_._v("(多版本并发控制)")]),_._v("。")]),_._v(" "),v("p",[_._v("对数据库进行修改时，"),v("code",[_._v("InnoDB")]),_._v("存储引擎不但会产生"),v("code",[_._v("redo")]),_._v("，还会产生相对应的"),v("code",[_._v("undo")]),_._v("，如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条"),v("strong",[_._v("ROLLBACK")]),_._v("语句请求回滚，就可以借助该"),v("code",[_._v("undo")]),_._v("进行"),v("strong",[_._v("回滚")]),_._v("。")]),_._v(" "),v("p",[v("code",[_._v("undo log")]),_._v(" 存放在数据库内部的一个特殊段("),v("code",[_._v("segment")]),_._v(")中，这个段称为"),v("code",[_._v("undo log segment")]),_._v("。")]),_._v(" "),v("p",[v("code",[_._v("undo log")]),_._v("和"),v("code",[_._v("redo log")]),_._v("记录物理日志不一样，它是"),v("strong",[_._v("逻辑日志")]),_._v("。"),v("code",[_._v("InnoDB")]),_._v("存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个"),v("code",[_._v("INSERT")]),_._v("，"),v("code",[_._v("InnoDB")]),_._v("存储引擎会完成一个"),v("code",[_._v("DELETE")]),_._v("；\n对于每个"),v("code",[_._v("DELETE")]),_._v("，"),v("code",[_._v("InnoDB")]),_._v("存储引擎会执行一个"),v("code",[_._v("INSERT")]),_._v("；对于每个"),v("code",[_._v("UPDATE")]),_._v("，"),v("code",[_._v("InnoDB")]),_._v("存储引擎会执行一个相反的"),v("code",[_._v("UPDATE")]),_._v("。")]),_._v(" "),v("p",[_._v("除了"),v("code",[_._v("回滚")]),_._v("操作，"),v("code",[_._v("undo")]),_._v("的两一个作用是"),v("code",[_._v("MVCC")]),_._v("，即在"),v("code",[_._v("InnoDB")]),_._v("存储引擎中"),v("code",[_._v("MVCC")]),_._v("的实现是通过"),v("code",[_._v("undo")]),_._v("来完成的。当用户读取一行记录时，若该记录已经被其他的事务占用，当前事务可以通过"),v("code",[_._v("undo")]),_._v("读取之前的行版本信息，以此实现"),v("strong",[_._v("非锁定读取")]),_._v("。")]),_._v(" "),v("p",[_._v("最后也是最重要的一点是，"),v("strong",[v("code",[_._v("undo log")]),_._v("也会产生"),v("code",[_._v("redo log")]),_._v("，因为"),v("code",[_._v("undo log")]),_._v("也要实现持久性保护")]),_._v("。")]),_._v(" "),v("h4",{attrs:{id:"_2-undo-log-的存储方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-undo-log-的存储方式"}},[_._v("#")]),_._v(" 2. undo log 的存储方式")]),_._v(" "),v("p",[v("code",[_._v("InnoDB")]),_._v("存储引擎对"),v("code",[_._v("undo")]),_._v("的管理采用段的方式。"),v("code",[_._v("rollback segment")]),_._v("称为"),v("strong",[_._v("回滚段")]),_._v("，每个回滚段中有1024个"),v("code",[_._v("undo log segment")]),_._v("。")]),_._v(" "),v("h4",{attrs:{id:"_3-undo-log-回滚日志-总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-undo-log-回滚日志-总结"}},[_._v("#")]),_._v(" 3. undo log（回滚日志）总结 🎉")]),_._v(" "),v("ol",[v("li",[_._v("是 Innodb 存储引擎层生成的日志，实现了事务中的"),v("strong",[_._v("原子性")]),_._v("，主要用于事务回滚和"),v("strong",[_._v("MVCC")]),_._v("；")]),_._v(" "),v("li",[_._v("一个事务在执行过程中，在还没有提交事务之前，如果MySQL 发生了崩溃，可以通过这个日志（"),v("strong",[_._v("undo log")]),_._v("）回滚到事务之前的数据；")]),_._v(" "),v("li",[_._v("MVCC 是通过 "),v("strong",[_._v("ReadView")]),_._v(" + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 ReadView 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。")])]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("redo log 和 undo log 区别在哪？")]),_._v(" "),v("ul",[v("li",[_._v("redo log 记录了此次事务**「"),v("strong",[_._v("完成后")]),_._v("」的数据状态，记录的是更新之「"),v("strong",[_._v("后")]),_._v("」**的值；")]),_._v(" "),v("li",[_._v("undo log 记录了此次事务**「"),v("strong",[_._v("开始前")]),_._v("」的数据状态，记录的是更新之「"),v("strong",[_._v("前")]),_._v("」**的值；")])])]),_._v(" "),v("h3",{attrs:{id:"purge"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#purge"}},[_._v("#")]),_._v(" purge")]),_._v(" "),v("p",[v("code",[_._v("purge")]),_._v(" 用于最终完成"),v("code",[_._v("delete")]),_._v("和"),v("code",[_._v("update")]),_._v("操作。这样设计是因为"),v("code",[_._v("InnoDB")]),_._v("存储引擎支持"),v("strong",[_._v("MVCC")]),_._v("，所以记录不能再事务提交时立即进行处理。这时其他事务可能正在引用这行，故"),v("code",[_._v("InnoDB")]),_._v("存储引擎需要保存记录之前的版本。\n而是否可以删除该条记录通过"),v("code",[_._v("purge")]),_._v("来进行判断。若该行记录已不被任何事务引用，那么就可以进行真正的"),v("code",[_._v("delete")]),_._v("操作。")]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("官方解释")]),_._v(" "),v("p",[_._v("In the InnoDB multi-versioning scheme, a row is not physically removed from the database immediately when you delete it with an SQL statement. InnoDB only physically removes the corresponding row and its index records when it discards the update undo log record written for the deletion. This removal operation is called a purge, and it is quite fast, usually taking the same order of time as the SQL statement that did the deletion.")])]),_._v(" "),v("h3",{attrs:{id:"group-commit"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#group-commit"}},[_._v("#")]),_._v(" group commit")]),_._v(" "),v("p",[_._v("组提交(group commit)即一次"),v("code",[_._v("fsync")]),_._v("可以刷新确保多个事务日志被写入文件。")]),_._v(" "),v("h2",{attrs:{id:"事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[_._v("#")]),_._v(" 事务隔离级别")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("序号")]),_._v(" "),v("th",[_._v("英文名")]),_._v(" "),v("th",[_._v("中文名")]),_._v(" "),v("th",[_._v("脏读")]),_._v(" "),v("th",[_._v("不可重复读")]),_._v(" "),v("th",[_._v("幻读")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("1")]),_._v(" "),v("td",[_._v("read_uncommited")]),_._v(" "),v("td",[_._v("读未提交")]),_._v(" "),v("td",[_._v("❌")]),_._v(" "),v("td",[_._v("❌")]),_._v(" "),v("td",[_._v("❌")])]),_._v(" "),v("tr",[v("td",[_._v("2")]),_._v(" "),v("td",[_._v("read_commited")]),_._v(" "),v("td",[_._v("读已提交")]),_._v(" "),v("td",[_._v("✅")]),_._v(" "),v("td",[_._v("❌")]),_._v(" "),v("td",[_._v("❌")])]),_._v(" "),v("tr",[v("td",[_._v("3")]),_._v(" "),v("td",[_._v("repeatable_read")]),_._v(" "),v("td",[_._v("可重复读")]),_._v(" "),v("td",[_._v("✅")]),_._v(" "),v("td",[_._v("✅")]),_._v(" "),v("td",[_._v("❌")])]),_._v(" "),v("tr",[v("td",[_._v("4")]),_._v(" "),v("td",[_._v("serilizable")]),_._v(" "),v("td",[_._v("序列化读")]),_._v(" "),v("td",[_._v("✅")]),_._v(" "),v("td",[_._v("✅")]),_._v(" "),v("td",[_._v("✅")])])])]),_._v(" "),v("ul",[v("li",[_._v("❌  表示当前事务级别未解决了此问题")]),_._v(" "),v("li",[_._v("✅ 表示当前事务级别已经解决了此问题")])]),_._v(" "),v("h3",{attrs:{id:"脏读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#脏读"}},[_._v("#")]),_._v(" 脏读")]),_._v(" "),v("p",[v("strong",[_._v("脏读")]),_._v("重点在于"),v("code",[_._v("事务A")]),_._v("读取"),v("code",[_._v("事务B")]),_._v("尚未提交的更改数据("),v("strong",[_._v("UPDATE")]),_._v(")并在这个数据的基础上进行操作，这时候如果"),v("code",[_._v("事务B")]),_._v("回滚，那么"),v("code",[_._v("事务A")]),_._v("读到的数据是不被承认的。产生的流程如下：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("序号")]),_._v(" "),v("th",[_._v("事务A")]),_._v(" "),v("th",[_._v("事务B")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("1")]),_._v(" "),v("td",[_._v("start transaction;")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("2")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("start transaction;")])]),_._v(" "),v("tr",[v("td",[_._v("3")]),_._v(" "),v("td",[_._v("select balance from account where id=1;  (结果为100)")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("4")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("update account set balance = 200 where id=1;")])]),_._v(" "),v("tr",[v("td",[_._v("5")]),_._v(" "),v("td",[_._v("select balance from account where id=1;  (结果为200)")]),_._v(" "),v("td")])])]),_._v(" "),v("h3",{attrs:{id:"不可重复读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读"}},[_._v("#")]),_._v(" 不可重复读")]),_._v(" "),v("p",[v("strong",[_._v("不可重复读")]),_._v("是指在同一个事务内，两次相同的查询返回了不同的结果。"),v("code",[_._v("事务A")]),_._v("第一次读取某一条数据后，"),v("code",[_._v("事务B")]),v("strong",[_._v("更新该数据并提交了事务")]),_._v("，"),v("code",[_._v("事务A")]),_._v("再次读取该数据，两次读取便得到了不同的结果。")]),_._v(" "),v("p",[_._v("不可重复读和脏读的区别是："),v("strong",[_._v("脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据")]),_._v("，但是其违反了数据库一致性的要求。")]),_._v(" "),v("p",[_._v("产生的流程如下：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("序号")]),_._v(" "),v("th",[_._v("事务A")]),_._v(" "),v("th",[_._v("事务B")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("1")]),_._v(" "),v("td",[_._v("start transaction;")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("2")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("start transaction;")])]),_._v(" "),v("tr",[v("td",[_._v("3")]),_._v(" "),v("td",[_._v("select balance from account where id=1;  (结果为100)")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("4")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("update account set balance = 200 where id=1;")])]),_._v(" "),v("tr",[v("td",[_._v("5")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("commit;")])]),_._v(" "),v("tr",[v("td",[_._v("6")]),_._v(" "),v("td",[_._v("select balance from account where id=1;  (结果为200)")]),_._v(" "),v("td")])])]),_._v(" "),v("p",[v("strong",[_._v("不可重复读有一种特殊情况，两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失，这种情况就是第二类丢失更新")]),_._v("。产生的流程如下：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("序号")]),_._v(" "),v("th",[_._v("事务A")]),_._v(" "),v("th",[_._v("事务B")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("1")]),_._v(" "),v("td",[_._v("start transaction;")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("2")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("start transaction;")])]),_._v(" "),v("tr",[v("td",[_._v("3")]),_._v(" "),v("td",[_._v("select balance from account where id=1;  (结果为100)")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("4")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("select balance from account where id=1;  (结果为100)")])]),_._v(" "),v("tr",[v("td",[_._v("5")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("update account set balance = 0 where id=1; （取出100元）")])]),_._v(" "),v("tr",[v("td",[_._v("6")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("commit;")])]),_._v(" "),v("tr",[v("td",[_._v("5")]),_._v(" "),v("td",[_._v("update account set balance = 200 where id=1; （存入100元）")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("6")]),_._v(" "),v("td",[_._v("commit;")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("6")]),_._v(" "),v("td",[_._v("select balance from account where id=1;  (结果为200，丢失更新)")]),_._v(" "),v("td")])])]),_._v(" "),v("p",[_._v("我们在平时写代码的时候，需要特别注意"),v("strong",[_._v("第二类丢失更新")]),_._v("(覆盖丢失/两次更新问题，Second lost update) 的问题，可以使用乐观锁的解决这个问题。")]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("第一类丢失更新(回滚丢失，Lost update)")]),_._v(" "),v("p",[_._v("在"),v("code",[_._v("事务A")]),_._v("期间，"),v("code",[_._v("事务B")]),_._v("对数据进行了更新并提交；在"),v("code",[_._v("事务A")]),_._v("回滚之后，覆盖了"),v("code",[_._v("事务B")]),_._v("已经提交的数据。"),v("strong",[_._v("SQL92没有定义这种现象，标准定义的所有隔离级别都不允许第一类丢失更新发生。")])])]),_._v(" "),v("h3",{attrs:{id:"幻读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#幻读"}},[_._v("#")]),_._v(" 幻读")]),_._v(" "),v("p",[v("strong",[_._v("幻读")]),_._v("重点在于"),v("code",[_._v("A事务")]),_._v("读取"),v("code",[_._v("B事务")]),_._v("提交的"),v("strong",[_._v("新增数据(INSERT)")]),_._v(",会引发幻读问题。幻读一般发生在计算统计数据的事务中。产生的流程如下：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("序号")]),_._v(" "),v("th",[_._v("事务A")]),_._v(" "),v("th",[_._v("事务B")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("1")]),_._v(" "),v("td",[_._v("start transaction;")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("2")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("start transaction;")])]),_._v(" "),v("tr",[v("td",[_._v("3")]),_._v(" "),v("td",[_._v("select count(*) from account_transfer_record where account_id=1;  (结果为0)")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("4")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("insert into account_transfer_record(id,account_id,amount) values(1,1,100);")])]),_._v(" "),v("tr",[v("td",[_._v("5")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("commit;")])]),_._v(" "),v("tr",[v("td",[_._v("6")]),_._v(" "),v("td",[_._v("select count(*) from account_transfer_record where account_id=1;  (结果为1)")]),_._v(" "),v("td")])])]),_._v(" "),v("p",[v("code",[_._v("MySQL Innodb存储引擎")]),_._v("的默认支持的隔离级别是"),v("code",[_._v("REPEATABLE-READ（可重读）")]),_._v("。可以通过命令查看数据库事务数据库隔离级别：")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("-- `MySQL 8.0` 该命令改为`SELECT @@transaction_isolation;`")]),_._v("\n\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),_._v(" @"),v("span",{pre:!0,attrs:{class:"token variable"}},[_._v("@tx_isolation")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br")])]),v("p",[_._v("很多公司把"),v("code",[_._v("MySQL Innodb存储引擎")]),_._v("的隔离级别设置成"),v("code",[_._v("READ-COMMITTED")]),_._v("，是为了防止频繁的出现死锁，所以我们平时在写代码的时候需要注意。")]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("延伸思考")]),_._v(" "),v("p",[_._v("我们知道，"),v("code",[_._v("MySQL Innodb")]),_._v("存储引擎默认的事务隔离级别是"),v("code",[_._v("RR")]),_._v("，是会出现幻读的，那么它是如何避免幻读的呢？")])]),_._v(" "),v("h2",{attrs:{id:"mysql是怎么解决幻读问题的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql是怎么解决幻读问题的"}},[_._v("#")]),_._v(" MySQL是怎么解决幻读问题的？")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("快照读")]),_._v(": 通过"),v("code",[_._v("MVCC")]),_._v("（并发多版本控制）来解决幻读问题\n"),v("ul",[v("li",[_._v("MVCC 的实现依赖于："),v("code",[_._v("隐藏字段")]),_._v("、"),v("code",[_._v("Read View")]),_._v("、"),v("code",[_._v("undo log")])]),_._v(" "),v("li",[_._v("隐藏字段：事务ID、回滚指针、DB_ROW_ID（如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引）")])])]),_._v(" "),v("li",[v("strong",[_._v("实时读")]),_._v("（执行 "),v("code",[_._v("select...for update/lock in share mode")]),_._v("、"),v("code",[_._v("insert")]),_._v("、"),v("code",[_._v("update")]),_._v("、"),v("code",[_._v("delete")]),_._v("）: 通过"),v("strong",[_._v("采用"),v("code",[_._v("Next-Key Locking")]),_._v("机制")]),_._v("来解决幻读问题")])]),_._v(" "),v("h3",{attrs:{id:"快照读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#快照读"}},[_._v("#")]),_._v(" 快照读")]),_._v(" "),v("p",[v("code",[_._v("MySQL")]),_._v("默认的隔离级别是"),v("strong",[_._v("可重复读(RR)")]),_._v("，这种隔离级别下，普通的"),v("code",[_._v("SELECT")]),_._v("语句都是"),v("strong",[_._v("快照读")]),_._v("，也就是在一个事务内，多次执行"),v("code",[_._v("SELECT")]),_._v("语句，查询到的数据都是事务开始时那个状态的数据。")]),_._v(" "),v("p",[v("strong",[_._v("快照读")]),_._v("就是在每一行数据中额外保存"),v("strong",[_._v("两个隐藏的列")]),_._v("，分别是：插入这个数据行时的版本号/删除这个数据行时的版本号（"),v("strong",[_._v("事务的ID")]),_._v(" | 可能为空），滚动指针(指向"),v("code",[_._v("undo log")]),_._v("中用于事务回滚的日志记录)。")]),_._v(" "),v("p",[_._v("事务在对数据修改后，进行保存时，如果数据行的当前版本号与事务开始取得数据的版本号一致就保存成功，否则保存失败。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("insert")])])]),_._v(" "),v("p",[_._v("插入一行数据时，将"),v("strong",[_._v("事务的ID")]),_._v("作为数据行的创建版本号。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("delete")])])]),_._v(" "),v("p",[_._v("执行删除操作时，会将原数据行的删除版本号设置为当前"),v("strong",[_._v("事务的ID")]),_._v("，然后根据原数据行生成一条"),v("code",[_._v("INSERT")]),_._v("语句，写入"),v("code",[_._v("undo log")]),_._v("，用于事务执行失败时回滚。\n"),v("code",[_._v("delete")]),_._v("操作实际上"),v("strong",[_._v("不会直接删除")]),_._v("，而是将"),v("code",[_._v("delete")]),_._v("对象打上"),v("code",[_._v("delete flag")]),_._v("，标记为删除，最终的删除操作是"),v("code",[_._v("purge")]),_._v("线程完成的。\n但是会将数据行的删除版本号设置为当前的"),v("strong",[_._v("事务的ID")]),_._v("，这样后面的"),v("strong",[_._v("事务B")]),_._v("即便查到这行数据由于"),v("strong",[_._v("事务B")]),_._v("的ID > 删除版本号，也会忽略这条数据。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("update")])])]),_._v(" "),v("p",[_._v("更新时可以简单的认为是先将旧数据删除，然后插入一条新数据。")]),_._v(" "),v("p",[_._v("所以执行更新操作时，其实是会将原数据行的删除版本号设置为当前"),v("strong",[_._v("事务的ID")]),_._v("，生成一条"),v("code",[_._v("INSERT")]),_._v("语句，写入"),v("code",[_._v("undo log")]),_._v("，用于事务执行失败时回滚。\n插入一条新的数据，将"),v("strong",[_._v("事务的ID")]),_._v("作为数据行的的创建版本号。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("select")])])]),_._v(" "),v("p",[_._v("首先读取数据的前提条件是：数据行的创建版本号"),v("code",[_._v("<=")]),_._v("当前事务版本号 （否则数据是后面的事务创建出来的）、数据行删除版本号为空或者"),v("code",[_._v(">")]),_._v("当前事务版本号的数据（否则数据已经被标记删除了)")]),_._v(" "),v("p",[_._v("如果该行数据没有被加行锁中的"),v("code",[_._v("X")]),_._v("锁（也就是没有其他事务对这行数据进行修改），那么直接读取数据。")]),_._v(" "),v("p",[_._v("如果该行数据被加了行锁"),v("code",[_._v("X")]),_._v("锁（也就是现在有其他事务对这行数据进行修改），那么读数据的事务不会进行等待，而是回去"),v("code",[_._v("undo log")]),_._v("端里面读之前版本的数据（这里存储的数据本身是用于回滚的），\n在"),v("strong",[_._v("可重复读")]),_._v("的隔离级别下，从"),v("code",[_._v("undo log")]),_._v("中读取的数据总是事务开始时的快照数据，在"),v("strong",[_._v("提交读")]),_._v("的隔离级别下，从"),v("code",[_._v("undo log")]),_._v("中读取的总是最新的快照数据。")]),_._v(" "),v("h3",{attrs:{id:"实时读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实时读"}},[_._v("#")]),_._v(" 实时读")]),_._v(" "),v("p",[_._v("使用"),v("code",[_._v("一致性读定锁")]),_._v("进行查询时就是"),v("strong",[_._v("实时读")]),_._v("，读(locking read)操作：")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("-")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FOR")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("UPDATE")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("X锁"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("-")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("LOCK")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("IN")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SHARE")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("MODE")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("S锁"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br")])]),v("p",[_._v("使用 "),v("strong",[_._v("Next-Key Lock")]),_._v("（"),v("code",[_._v("Gap Lock")]),_._v("+"),v("code",[_._v("Record Lock")]),_._v(" ，锁定一个范围，并且锁定记录本身）"),v("strong",[_._v("加锁")]),_._v("，来解决幻读问题。")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"mvcc-实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvcc-实现原理"}},[_._v("#")]),_._v(" MVCC 实现原理 🎉")]),_._v(" "),v("p",[_._v("MVCC 的实现依赖于：隐藏字段、Read View、undo log")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("通过事务ID（DB_TRX_ID）和 ReadView 来判断数据的可见性")]),_._v("；")]),_._v(" "),v("li",[_._v("如可见，则返回 ReadView 规则的版本数据；")]),_._v(" "),v("li",[_._v("如不可见，则通过"),v("strong",[_._v("回滚指针")]),_._v("（DB_ROLL_PTR）找到 undo log 中的历史版本数据；")])]),_._v(" "),v("h3",{attrs:{id:"隐藏字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#隐藏字段"}},[_._v("#")]),_._v(" 隐藏字段")]),_._v(" "),v("p",[_._v("InnoDB 存储引擎为每行数据添加了三个 隐藏字段：")]),_._v(" "),v("ol",[v("li",[_._v("DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务ID。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除")]),_._v(" "),v("li",[_._v("DB_ROLL_PTR（7字节） "),v("strong",[_._v("回滚指针")]),_._v("，指向该行的 undo log 。如果该行未被更新，则为空")]),_._v(" "),v("li",[_._v("DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引")])]),_._v(" "),v("h3",{attrs:{id:"readview"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#readview"}},[_._v("#")]),_._v(" ReadView")]),_._v(" "),v("blockquote",[v("p",[_._v("Read view lists the trx ids of those transactions for which a consistent read should not see the modifications to the database.")])]),_._v(" "),v("p",[_._v("ReadView是事务开启时，"),v("strong",[_._v("当前所有活跃事务（还未提交的事务）的一个集合")]),_._v("，ReadView数据结构决定了不同事务隔离级别下，数据的可见性。")]),_._v(" "),v("ol",[v("li",[_._v("ReadView的组成\n"),v("ul",[v("li",[_._v("m_ids："),v("strong",[_._v("存了当前数据库系统中正处于活跃（没有 commit）的事务的ID列表")])]),_._v(" "),v("li",[_._v("min_trx_id：m_ids里最小的值；")]),_._v(" "),v("li",[_._v("max_trx_id：mysql下一个要生成的事务id，就是最大事务id；")]),_._v(" "),v("li",[_._v("creator_trx_id：当前这个事务的id；")])])]),_._v(" "),v("li",[_._v("数据可见性：InnoDB 会将该记录行的 DB_TRX_ID 与 Read View 中的一些变量及当前事务 ID 进行比较\n"),v("ul",[v("li",[_._v("当 DB_TRX_ID < min_trx_id 表示此版本是已经提交的事务生成的，数据可见")]),_._v(" "),v("li",[_._v("当 DB_TRX_ID > max_trx_id 表示此版本是由将来启动的事务生成的，数据不可见")]),_._v(" "),v("li",[_._v("当 DB_TRX_ID >= min_trx_id & DB_TRX_ID <= max_trx_id\n"),v("ul",[v("li",[_._v("如果 DB_TRX_ID 在 m_ids 的数组中，数据不可见，但对当前自己的事务是可见的")]),_._v(" "),v("li",[_._v("如果 DB_TRX_ID 不在 m_ids 的数组中，数据可见")])])])])]),_._v(" "),v("li",[_._v("生成的时机\n"),v("ul",[v("li",[_._v("RC：每个查询都单独构建ReadView")]),_._v(" "),v("li",[_._v("RR：事务开始后第一条select时生成一个ReadView，一直用到事务结束")])])])]),_._v(" "),v("h3",{attrs:{id:"undo-log-版本链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#undo-log-版本链"}},[_._v("#")]),_._v(" undo log 版本链")]),_._v(" "),v("p",[v("img",{attrs:{src:"/img/mysql/undo-log-link.png",alt:"undo-log-link.png"}})]),_._v(" "),v("ol",[v("li",[_._v("假设有一个事务A（事务ID=50）插入一条数据，那么此时这条数据的隐藏字段：事务ID=50、"),v("strong",[_._v("回滚指针")]),_._v("（DB_ROLL_PTR）指向的空的undo log；")]),_._v(" "),v("li",[_._v("当有另一个事务B（事务ID=51）更新这条数据，那么此时更新之前会生成一个 undo log 记录（事务A的值），这条数据的隐藏字段：事务ID=51、"),v("strong",[_._v("回滚指针")]),_._v("指向刚生成的undo log；")]),_._v(" "),v("li",[_._v("当再有一个事务C更新这条数据，同步骤2，这样就形成了 undo log 版本链；")])]),_._v(" "),v("p",[v("strong",[_._v("参考文档")])]),_._v(" "),v("ul",[v("li",[_._v("《MySQL技术内幕 InnoDB存储引擎 第2版》")]),_._v(" "),v("li",[v("a",{attrs:{href:"https://juejin.cn/post/7120460698953941029#heading-6",target:"_blank",rel:"noopener noreferrer"}},[_._v("MySQL 日志：undo log、redo log、binlog"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=e.exports}}]);