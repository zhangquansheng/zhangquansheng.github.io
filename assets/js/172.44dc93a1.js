(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{480:function(e,r,t){"use strict";t.r(r);var _=t(10),v=Object(_.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),r("h2",{attrs:{id:"系统部署架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#系统部署架构"}},[e._v("#")]),e._v(" 系统部署架构")]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/rocketmq/rocketmq-arch.png",alt:"rocketmq-arch"}})]),e._v(" "),r("p",[e._v("图中所涉及到的概念如下所述：")]),e._v(" "),r("ul",[r("li",[e._v("Name Server：是一个几乎无状态节点，可集群部署，在消息队列 RocketMQ 版中提供命名服务，更新和发现 Broker 服务。")]),e._v(" "),r("li",[e._v("Broker：消息中转角色，负责存储消息，转发消息。分为 Master Broker 和 Slave Broker，一个 Master Broker 可以对应多个 Slave Broker，但是一个 Slave Broker 只能对应一个 Master Broker。Broker 启动后需要完成一次将自己注册至 Name Server 的操作；随后每隔 30s 定期向 Name Server 上报 Topic 路由信息。")]),e._v(" "),r("li",[e._v("生产者：与 Name Server 集群中的其中一个节点（随机）建立长链接（Keep-alive），定期从 Name Server 读取 Topic 路由信息，并向提供 Topic 服务的 Master Broker 建立长链接，且定时向 Master Broker 发送心跳。")]),e._v(" "),r("li",[e._v("消费者：与 Name Server 集群中的其中一个节点（随机）建立长连接，定期从 Name Server 拉取 Topic 路由信息，并向提供 Topic 服务的 Master Broker、Slave Broker 建立长连接，且定时向 Master Broker、Slave Broker 发送心跳。Consumer 既可以从 Master Broker 订阅消息，也可以从 Slave Broker 订阅消息，订阅规则由 Broker 配置决定。")])]),e._v(" "),r("h2",{attrs:{id:"rocketmq-的设计理念和目标"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-的设计理念和目标"}},[e._v("#")]),e._v(" RocketMQ 的设计理念和目标")]),e._v(" "),r("h3",{attrs:{id:"设计理念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计理念"}},[e._v("#")]),e._v(" 设计理念")]),e._v(" "),r("p",[e._v("RocketMQ 设计基于主题的发布订阅模式，其核心功能包括消息发送、消息存储（Broker）、消息消费，整体设计追求简单和性能第一，主要体现在如下三个方面。")]),e._v(" "),r("p",[e._v("首先，"),r("code",[e._v("NameServer")]),e._v("设计极其简单，摒弃了"),r("code",[e._v("Zookeeper")]),e._v("充当注册中心,采用自研"),r("code",[e._v("NameServer")]),e._v("实现元数据的管理(Topic路由信息等)，"),r("strong",[e._v("追求最终一致性，并且能容忍分钟级的不一致")]),e._v("。\n正式基于此种情况，"),r("strong",[e._v("RocketMQ的"),r("code",[e._v("NameServer")]),e._v("集群间互不通信")]),e._v("，极大地降低了"),r("code",[e._v("NameServer")]),e._v("实现的复杂程度，对网络的要求也降低不少，性能相对于"),r("code",[e._v("Zookeeper")]),e._v("有较大提升。")]),e._v(" "),r("p",[e._v("其次，是高效的IO存储机制。RocketMQ 追求消息发送的高吞吐量，消息存储文件设计成"),r("strong",[e._v("文件组")]),e._v("的概念，组内单个文件大小固定，方便引入"),r("strong",[e._v("内存映射机制")]),e._v("，所有主题的消息存储基于"),r("strong",[e._v("顺序写")]),e._v("，\n极大地提升了消息写性能，同时为了兼顾消息消费与消息查找，引入了"),r("strong",[e._v("消息消费队列文件")]),e._v("与"),r("strong",[e._v("索引文件")])]),e._v(" "),r("p",[e._v("最后，容忍存在设计缺陷，RocketMQ 只保证消息被消费者消费，但设计上允许消息被重复消费，这样极大地简化了消息中间件的内核，使得实现消息发送高可用变得非常简单与高效，\n"),r("strong",[e._v("消息重复问题由消费者在消息消费时实现幂等")]),e._v("。")]),e._v(" "),r("h3",{attrs:{id:"设计目标"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计目标"}},[e._v("#")]),e._v(" 设计目标")]),e._v(" "),r("p",[e._v("RocketMQ 需要解决一下问题：")]),e._v(" "),r("h4",{attrs:{id:"_1-架构模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-架构模式"}},[e._v("#")]),e._v(" 1.架构模式")]),e._v(" "),r("p",[e._v("RocketMQ 采用发布订阅模式，基本组件：消息发送者，消息服务器（消息存储），消息消费，路由发现。")]),e._v(" "),r("h4",{attrs:{id:"_2-顺序消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-顺序消息"}},[e._v("#")]),e._v(" 2.顺序消息")]),e._v(" "),r("p",[e._v("顺序消息，指消息消费者按照消息到达消息存储服务器的顺序消费，"),r("strong",[e._v("RocketMQ 可以严格保证消息有序")]),e._v("。")]),e._v(" "),r("h4",{attrs:{id:"_3-消息过滤"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-消息过滤"}},[e._v("#")]),e._v(" 3.消息过滤")]),e._v(" "),r("p",[e._v("消息过滤，指消息消费时，消息消费者可以对同一主题下的消息按照规则只消费自己感兴趣的消息。RocketMQ 消息过滤支持在服务端和消费端的消息过滤机制。")]),e._v(" "),r("ul",[r("li",[e._v("消息在"),r("code",[e._v("Broker")]),e._v("端过滤。"),r("code",[e._v("Broker")]),e._v("只将消息消费者感兴趣的消息发送消息消费者。")]),e._v(" "),r("li",[e._v("消息在消息消费端过滤。过滤方式由消费者自定义，缺点是无用的消息会从"),r("code",[e._v("Broker")]),e._v("传输到消费端。")])]),e._v(" "),r("h4",{attrs:{id:"_4-消息存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-消息存储"}},[e._v("#")]),e._v(" 4.消息存储")]),e._v(" "),r("p",[e._v("核心实现是消息存储，两个维度考量：消息堆积能力和消息存储性能。**引入内存映射机制和顺序写提升消息存储性能，**为了避免消息无限在消息存储服务器中累积，引入消息文件过期机制和文件存储空间报警机制。")]),e._v(" "),r("h4",{attrs:{id:"_5-消息高可用性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-消息高可用性"}},[e._v("#")]),e._v(" 5.消息高可用性")]),e._v(" "),r("p",[e._v("消息可靠性通常有以下几种情况：")]),e._v(" "),r("ol",[r("li",[e._v("Broker 正常关机")]),e._v(" "),r("li",[e._v("Broker异常 Crash")]),e._v(" "),r("li",[e._v("OS Crash")]),e._v(" "),r("li",[e._v("机器断电，但是能立即恢复供电")]),e._v(" "),r("li",[e._v("机器无法开机")]),e._v(" "),r("li",[e._v("磁盘设备损坏")])]),e._v(" "),r("p",[e._v("情况 1~4 的 RocketMQ 在"),r("strong",[e._v("同步刷盘模式下可以确保不丢失消息，在异步刷盘模式下，会丢失少量消息")]),e._v("。情况 5~6 属于单点故障，一旦发生，该节点消息全部丢失，若开启异步复制，RocketMQ 能保证只丢失少量消息。")]),e._v(" "),r("h4",{attrs:{id:"_6-消息到达-消费-低延迟"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-消息到达-消费-低延迟"}},[e._v("#")]),e._v(" 6.消息到达（消费）低延迟")]),e._v(" "),r("p",[e._v("RocketMQ在消息不发生堆积时，以"),r("strong",[e._v("长轮询")]),e._v("模式实现准实时的消息推送模式")]),e._v(" "),r("h4",{attrs:{id:"_7-确保消息必须被消费一次"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-确保消息必须被消费一次"}},[e._v("#")]),e._v(" 7.确保消息必须被消费一次")]),e._v(" "),r("p",[e._v("RocketMQ 通过消息确认机制（ACK）来确保消息至少被消费一次（由于ACK消息有可能丢失等原因，无法做到只被消费一次，有重复消费的可能）。")]),e._v(" "),r("h4",{attrs:{id:"_8-回溯消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-回溯消息"}},[e._v("#")]),e._v(" 8.回溯消息")]),e._v(" "),r("p",[e._v("回溯消息，指已经消费成功但需要重新消费的消息。RocketMQ 支持按时间回溯消息，时间维度可精确到毫秒，可向前或向后回溯")]),e._v(" "),r("h4",{attrs:{id:"_9-消息堆积"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-消息堆积"}},[e._v("#")]),e._v(" 9.消息堆积")]),e._v(" "),r("p",[e._v("消息中间件的主要功能是异步解耦，必须具备应对前端的数据洪峰，提高后端系统的可用性，必然要求消息中间件具备一定的消息堆积能力。\nRocketMQ 消息存储使用磁盘文件（"),r("strong",[e._v("内存映射机制")]),e._v("），在物理布局上为多个大小相等的文件组成逻辑文件组，可以无限循环使用。"),r("strong",[e._v("RocketMQ消息存储提供过期机制，默认保留3天")]),e._v("。")]),e._v(" "),r("h4",{attrs:{id:"_10-定时消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-定时消息"}},[e._v("#")]),e._v(" 10.定时消息")]),e._v(" "),r("p",[e._v("定时消息，指消息发送到Broker后，不能被消费端立即消费，要到特定的时间点或等待特定的时间后才能被消费。"),r("strong",[e._v("RocketMQ只支持特定延迟级别")]),e._v("。若支持任意精度的定时消费，必须在消息服务端对消息进行排序，性能损耗很大。")]),e._v(" "),r("h4",{attrs:{id:"_11-消息重试机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-消息重试机制"}},[e._v("#")]),e._v(" 11.消息重试机制")]),e._v(" "),r("p",[e._v("消息重试，指消息在消费时，如果发送异常，消息中间件支持消息重新投递，RocketMQ支持消息重试机制.")]),e._v(" "),r("h2",{attrs:{id:"rocketmq-的存储机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-的存储机制"}},[e._v("#")]),e._v(" RocketMQ 的存储机制 🎉")]),e._v(" "),r("ol",[r("li",[r("strong",[e._v("CommitLog")]),e._v(" "),r("ol",[r("li",[r("strong",[e._v("消息主体以及元数据的存储主体")])]),e._v(" "),r("li",[e._v("单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量")]),e._v(" "),r("li",[e._v("消息主要是顺序写入日志文件，当文件满了，写入下一个文件。")])])]),e._v(" "),r("li",[r("strong",[e._v("ConsumeQueue")]),e._v(" "),r("ol",[r("li",[e._v("消息消费队列，引入的目的主要是提高消息消费的性能")]),e._v(" "),r("li",[e._v("ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 offset ，消息大小 size 和消息 Tag 的 HashCode 值")]),e._v(" "),r("li",[e._v("ConsumeQueue 文件可以看成是基于 topic 的 CommitLog 索引文件")])])]),e._v(" "),r("li",[e._v("IndexFile（索引文件）提供了一种可以通过"),r("code",[e._v("key")]),e._v("或时间区间来查询消息的方法")])]),e._v(" "),r("h2",{attrs:{id:"rocketmq-消费者的负载均衡策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-消费者的负载均衡策略"}},[e._v("#")]),e._v(" RocketMQ 消费者的负载均衡策略 🎉")]),e._v(" "),r("p",[e._v("消费者的负载均衡，简单来说就是将Topic下的MessageQueue分配给这些Consumer")]),e._v(" "),r("ul",[r("li",[e._v("平均分配")]),e._v(" "),r("li",[e._v("环形平均分配")]),e._v(" "),r("li")]),e._v(" "),r("h2",{attrs:{id:"kafka-与-rocketmq-的存储对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kafka-与-rocketmq-的存储对比"}},[e._v("#")]),e._v(" Kafka 与 RocketMQ 的存储对比 🎉")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("MQ")]),e._v(" "),r("th",[e._v("结构")]),e._v(" "),r("th",[e._v("存储")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("Kafka")]),e._v(" "),r("td",[e._v("topic 对应多个 partition，同一个服务器（Broker）会有多个 topic-partition 对，partition 为单主多从结构，主挂了会重新选择主（ZK）")]),e._v(" "),r("td",[e._v("消息直接存储在 partition 中，对单 topic 为顺序写")])]),e._v(" "),r("tr",[r("td",[e._v("RocketMQ")]),e._v(" "),r("td",[e._v("topic 对应多个 ConsumeQueue，同一个服务器（Broker）会有多个 topic-ConsumeQueue 对，ConsumeQueue 为多主多从结构，主有配置指定，主挂了由其他主提供服务")]),e._v(" "),r("td",[e._v("同一个服务器的所有消息都统一写到 CommitLog 文件中，ConsumeQueue 只存储在 CommitLog 中的起始offset、log大小、MessageTag的hashCode，数据量较少。")])])])]),e._v(" "),r("h2",{attrs:{id:"rocketmq-内存映射机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-内存映射机制"}},[e._v("#")]),e._v(" RocketMQ 内存映射机制 🎉")]),e._v(" "),r("p",[e._v("RocketMQ 通过使用内存映射文件（内存映射机制）来提高"),r("code",[e._v("IO访问性能")]),e._v("，无论是 CommitLog、 ConsumeQueue 还是 IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。")]),e._v(" "),r("hr"),e._v(" "),r("p",[r("strong",[e._v("参考文档")])]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://www.baeldung.com/apache-rocketmq-spring-boot",target:"_blank",rel:"noopener noreferrer"}},[e._v("apache-rocketmq-spring-boot"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://rocketmq.apache.org/docs/quick-start/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache RocketMQ 官方文档"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/apache/rocketmq",target:"_blank",rel:"noopener noreferrer"}},[e._v("RocketMQ 源码"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://code.aliyun.com/aliware_rocketmq/rocketmq-demo/tree/master",target:"_blank",rel:"noopener noreferrer"}},[e._v("阿里云消息队列（Message Queue）使用示例"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("《RocketMQ 技术内幕: RocketMQ 架构设计与实现原理 丁威 周继峰》")]),e._v(" "),r("li",[r("a",{attrs:{href:"http://www.tianshouzhi.com/api/tutorials/rocketmq/409",target:"_blank",rel:"noopener noreferrer"}},[e._v("消费者Rebalance机制"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=v.exports}}]);