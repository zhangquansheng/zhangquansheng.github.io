(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{443:function(t,o,_){"use strict";_.r(o);var v=_(10),l=Object(v.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"rocketmq-支持事务消息机制的实现原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-支持事务消息机制的实现原理"}},[t._v("#")]),t._v(" RocketMQ 支持事务消息机制的实现原理")]),t._v(" "),o("p",[t._v("Apache RocketMQ在4.3.0版中已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/rocketmq/rocketmq-transaction.jpeg",alt:"rocketmq-transaction"}})]),t._v(" "),o("h2",{attrs:{id:"_1-rocketmq事务消息流程概要"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-rocketmq事务消息流程概要"}},[t._v("#")]),t._v(" 1 RocketMQ事务消息流程概要")]),t._v(" "),o("p",[t._v("上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。")]),t._v(" "),o("ol",[o("li",[t._v("事务消息发送及提交：")])]),t._v(" "),o("ul",[o("li",[t._v("(1) 执行本地事务之前，"),o("strong",[t._v("发送消息（half消息）")])]),t._v(" "),o("li",[t._v("(2) "),o("strong",[t._v("服务端响应消息写入结果")])]),t._v(" "),o("li",[t._v("(3) "),o("strong",[t._v("根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）")])]),t._v(" "),o("li",[t._v("(4) "),o("strong",[t._v("根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见，Rollback操作，就对half消息进行删除）")])])]),t._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[t._v("补偿流程（MQ定时任务）：")])]),t._v(" "),o("ul",[o("li",[t._v("(1) "),o("strong",[t._v("对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”")])]),t._v(" "),o("li",[t._v("(2) "),o("strong",[t._v("Producer 收到回查消息，检查回查消息对应的本地事务的状态")])]),t._v(" "),o("li",[t._v("(3) "),o("strong",[t._v("根据本地事务状态，重新Commit或者Rollback")])])]),t._v(" "),o("p",[t._v("其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。")]),t._v(" "),o("h2",{attrs:{id:"_2-rocketmq事务消息设计"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-rocketmq事务消息设计"}},[t._v("#")]),t._v(" 2 RocketMQ事务消息设计")]),t._v(" "),o("ol",[o("li",[t._v("事务消息在"),o("strong",[t._v("一阶段")]),t._v("对用户不可见")])]),t._v(" "),o("p",[t._v("在RocketMQ事务消息的主要流程中，一阶段的消息如何对用户不可见。其中，事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。那么，如何做到写入消息但是对用户不可见呢？")]),t._v(" "),o("p",[t._v("RocketMQ事务消息的做法是：")]),t._v(" "),o("ul",[o("li",[o("strong",[t._v("如果消息是half消息，将备份原消息的主题与消息消费队列")]),t._v("，")]),t._v(" "),o("li",[o("strong",[t._v("然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息")]),t._v("，")]),t._v(" "),o("li",[o("strong",[t._v("然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者，发送回查事务状态请求，根据事务状态来决定是提交或回滚消息")]),t._v("。")])]),t._v(" "),o("p",[t._v("RocketMQ的具体实现策略是：")]),t._v(" "),o("p",[t._v("写入的如果事务消息，对消息的Topic和Queue等属性进行替换，同时将原来的Topic和Queue信息存储到消息的属性中，正因为消息主题被替换，故消息并不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费。其实改变消息主题是RocketMQ的常用“套路”，回想一下延时消息的实现机制。")]),t._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[t._v("Commit和Rollback操作以及Op消息的引入")])]),t._v(" "),o("p",[t._v("在完成一阶段写入一条对用户不可见的消息后，二阶段如果是Commit操作，则需要让消息对用户可见；如果是Rollback则需要撤销一阶段的消息。")]),t._v(" "),o("p",[t._v("先说Rollback的情况。对于Rollback，本身一阶段的消息对用户是不可见的，其实不需要真正撤销消息（实际上RocketMQ也无法去真正的删除一条消息，因为是顺序写文件的）。\n但是区别于这条消息没有确定状态（Pending状态，事务悬而未决），需要一个操作来标识这条消息的最终状态。")]),t._v(" "),o("p",[t._v("RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息已经确定的状态（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，\n说明这个事务的状态还无法确定（可能是二阶段失败了）。引入Op消息后，事务消息无论是Commit或者Rollback都会记录一个Op操作。")]),t._v(" "),o("p",[t._v("Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。")]),t._v(" "),o("ol",{attrs:{start:"3"}},[o("li",[t._v("Op消息的存储和对应关系")])]),t._v(" "),o("p",[t._v("RocketMQ将Op消息写入到全局一个特定的Topic中通过源码中的方法—TransactionalMessageUtil.buildOpTopic()；\n这个Topic是一个内部的Topic（像Half消息的Topic一样），不会被用户消费。")]),t._v(" "),o("p",[o("strong",[t._v("Op消息的内容为对应的"),o("code",[t._v("Half消息")]),t._v("的存储的"),o("code",[t._v("Offset")]),t._v("，这样通过"),o("code",[t._v("Op消息")]),t._v("能索引到"),o("code",[t._v("Half消息")]),t._v("进行后续的回查操作")]),t._v("。")]),t._v(" "),o("ol",{attrs:{start:"4"}},[o("li",[t._v("Half消息的索引构建")])]),t._v(" "),o("p",[t._v("在执行二阶段Commit操作时，需要构建出Half消息的索引。一阶段的Half消息由于是写到一个特殊的Topic，所以二阶段构建索引时需要读取出Half消息，\n并将Topic和Queue替换成真正的目标的Topic和Queue，之后通过一次普通消息的写入操作来生成一条对用户可见的消息。")]),t._v(" "),o("p",[t._v("所以RocketMQ事务消息二阶段其实是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程。")]),t._v(" "),o("ol",{attrs:{start:"5"}},[o("li",[o("strong",[t._v("如何处理二阶段失败的消息？")])])]),t._v(" "),o("p",[t._v("如果在RocketMQ事务消息的二阶段过程中失败了，例如在做Commit操作时，出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。")]),t._v(" "),o("p",[t._v("RocketMQ采用了一种"),o("strong",[t._v("补偿机制")]),t._v("，称为**“回查”**。Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），\n由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推进CheckPoint（记录那些事务消息的状态是确定的）。")]),t._v(" "),o("p",[o("strong",[t._v("值得注意的是，rocketmq并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息")]),t._v("。")])])}),[],!1,null,null,null);o.default=l.exports}}]);