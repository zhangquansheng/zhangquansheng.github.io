(window.webpackJsonp=window.webpackJsonp||[]).push([[171],{436:function(v,_,t){"use strict";t.r(_);var s=t(10),r=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"缓存问题之缓存穿透、缓存击穿、缓存雪崩及其解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存问题之缓存穿透、缓存击穿、缓存雪崩及其解决方案"}},[v._v("#")]),v._v(" 缓存问题之缓存穿透、缓存击穿、缓存雪崩及其解决方案")]),v._v(" "),_("h2",{attrs:{id:"缓存穿透"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[v._v("#")]),v._v(" 缓存穿透")]),v._v(" "),_("p",[_("strong",[v._v("缓存穿透")]),v._v("： 大量请求的"),_("code",[v._v("key")]),v._v("根本不存在于缓存中，导致请求直接到了数据库上。")]),v._v(" "),_("p",[_("strong",[v._v("解决方案")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("缓存空值/空值缓存")]),v._v("： 一种比较简单的解决办法，在第一次查询完不存在的数据后，将该"),_("code",[v._v("key")]),v._v("与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，\n这样则可以应对短时间的大量的该"),_("code",[v._v("key")]),v._v("（重复"),_("code",[v._v("KEY")]),v._v("）攻击，设置为较短的失效时间则是因为该值可能跟业务无关，存在意义不大，且该次的查询也未必是攻击者发起，\n没有长期存储的必要，故可以早点失效。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("BloomFilter(布隆过滤器)")]),v._v("： 特点是"),_("strong",[v._v("肯定不存在，可能存在")]),v._v("，所以可以把所有可能的查询条件生成一个"),_("code",[v._v("bitmap")]),v._v("，在进行数据库查询之前会使用这个"),_("code",[v._v("bitmap")]),v._v("进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。")])])]),v._v(" "),_("h2",{attrs:{id:"缓存击穿"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[v._v("#")]),v._v(" 缓存击穿")]),v._v(" "),_("p",[_("strong",[v._v("缓存击穿")]),v._v("： 大量的请求同时查询一个"),_("code",[v._v("key")]),v._v("时，此时这个"),_("code",[v._v("key")]),v._v("正好失效，就会导致大量的请求都打到数据库上面去。（"),_("strong",[v._v("缓存击穿")]),v._v("实际上是缓存雪崩的一个特例，是"),_("strong",[v._v("热点KEY失效问题")]),v._v("）")]),v._v(" "),_("p",[_("strong",[v._v("解决方案")]),v._v("： 上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁（"),_("strong",[v._v("分布式锁")]),v._v("）来锁住它。\n其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。")]),v._v(" "),_("h2",{attrs:{id:"缓存雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[v._v("#")]),v._v(" 缓存雪崩")]),v._v(" "),_("p",[_("strong",[v._v("缓存雪崩")]),v._v("： 当某一时刻发生大规模的缓存失效的情况，例如"),_("strong",[v._v("缓存同一时刻过期")]),v._v("、"),_("strong",[v._v("缓存服务宕机")]),v._v("等。")]),v._v(" "),_("p",[_("strong",[v._v("解决方案")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("对于缓存服务宕机的情况，事前可以使用集群缓存，保证缓存服务的高可用。事中可以使用本地缓存（例如："),_("code",[v._v("Caffeine")]),v._v("）+ "),_("code",[v._v("Hystrix")]),v._v("来支撑一阵。事后开启"),_("code",[v._v("Redis")]),v._v("持久化机制，尽快恢复缓存集群。")]),v._v(" "),_("li",[v._v("对于缓存同一时刻过期的情况，我们可以让他们的失效时间错开，比如在一个基础的时间上加上或者减去一个范围内的随机值。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);