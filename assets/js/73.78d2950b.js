(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{340:function(v,_,e){"use strict";e.r(_);var o=e(10),c=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"深入理解io模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#深入理解io模型"}},[v._v("#")]),v._v(" 深入理解IO模型 🔨")]),v._v(" "),_("p",[v._v("首先我们知道，操作系统为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为："),_("strong",[v._v("用户空间（User space）")]),v._v(" 和"),_("strong",[v._v("内核空间（Kernel space ）")]),v._v(" 。")]),v._v(" "),_("p",[v._v("我们在平常开发过程中接触最多的就是"),_("strong",[v._v("磁盘 IO（读写文件）"),_("strong",[v._v("和")]),v._v("网络 IO（网络请求和相应）。")])]),v._v(" "),_("p",[v._v("从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起"),_("code",[v._v("IO")]),v._v("调用（系统调用），操作系统负责的内核执行具体的"),_("code",[v._v("IO")]),v._v("操作。\n也就是说，我们的应用程序实际上只是发起了"),_("code",[v._v("IO")]),v._v("操作的调用而已，具体"),_("code",[v._v("IO")]),v._v("的执行是由操作系统的内核来完成的。")]),v._v(" "),_("p",[v._v("当应用程序发起"),_("code",[v._v("I/O")]),v._v(" 调用后，会经历两个步骤：")]),v._v(" "),_("ol",[_("li",[v._v("内核（Kernel）等待"),_("code",[v._v("I/O")]),v._v("设备准备好数据")]),v._v(" "),_("li",[v._v("内核（Kernel）将数据从内核空间拷贝到用户空间。")])]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 中"),_("code",[v._v("3")]),v._v("种常见"),_("code",[v._v("IO")]),v._v("模型："),_("code",[v._v("BIO")]),v._v("、"),_("code",[v._v("NIO")]),v._v("、"),_("code",[v._v("I/O多路复用")]),v._v("。")]),v._v(" "),_("p",[v._v("首先我们需要知道，"),_("code",[v._v("java")]),v._v("其实是一种解释型语言，通过"),_("code",[v._v("JVM")]),v._v("虚拟机将我们的"),_("code",[v._v(".java")]),v._v("文件转换为"),_("strong",[v._v("字节码文件")]),v._v("，然后调用我们"),_("code",[v._v("os")]),v._v("中的"),_("code",[v._v("syscall")]),v._v("方法，\n我们必须明确的是，无论怎么调用，一定最后要通过"),_("strong",[v._v("调用内核的方法")]),v._v("，然后调用我们的硬件。")]),v._v(" "),_("h2",{attrs:{id:"bio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bio"}},[v._v("#")]),v._v(" BIO")]),v._v(" "),_("p",[v._v("同步阻塞"),_("code",[v._v("IO")]),v._v("模型中，应用程序发起"),_("code",[v._v("read")]),v._v("调用后，会一直"),_("strong",[v._v("阻塞")]),v._v("，直到内核把数据拷贝到用户空间。为了同时相应多个并发的请求，必须实现多线程。\n每个线程处理一个请求，线程数随着并发连接数线性增长。")]),v._v(" "),_("h2",{attrs:{id:"nio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nio"}},[v._v("#")]),v._v(" NIO")]),v._v(" "),_("p",[v._v("同步非阻塞"),_("code",[v._v("IO")]),v._v("模型。"),_("code",[v._v("NIO")]),v._v("中客户端和服务器之间通过"),_("code",[v._v("Channel")]),v._v("通信。这些"),_("code",[v._v("Channel")]),v._v("都会被注册在"),_("code",[v._v("Selector")]),v._v("多路复用选择器上。\n"),_("code",[v._v("Selector")]),v._v("通过一个线程不停的轮询这些"),_("code",[v._v("Channel")]),v._v("，找出已经准备就绪的"),_("code",[v._v("Channel")]),v._v("执行"),_("code",[v._v("IO")]),v._v("操作（"),_("code",[v._v("C10K问题")]),v._v("）。")]),v._v(" "),_("p",[v._v("简单来说，"),_("code",[v._v("NIO")]),v._v("通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞"),_("code",[v._v("NIO")]),v._v("的特点。")]),v._v(" "),_("h2",{attrs:{id:"i-o多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#i-o多路复用"}},[v._v("#")]),v._v(" I/O多路复用")]),v._v(" "),_("p",[_("code",[v._v("NIO")]),v._v("每次都需啊哟遍历所有的客户端（"),_("code",[v._v("C10K")]),v._v("），是非常耗时的，其实很多的客户端可能就没有发送请求。"),_("code",[v._v("I/O多路复用模型")]),v._v("下是不需要这样的，\n而是把我们的"),_("code",[v._v("fds")]),v._v("文件发送给内核，然后内核根据多路复用器"),_("code",[v._v("select")]),v._v("去判断最后需要连接的客户端。")]),v._v(" "),_("blockquote",[_("p",[v._v("目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("select")]),v._v("调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。")]),v._v(" "),_("li",[_("code",[v._v("epoll")]),v._v("调用 ："),_("code",[v._v("linux 2.6")]),v._v(" 内核，属于"),_("code",[v._v("select")]),v._v("调用的增强版本，优化了"),_("code",[v._v("IO")]),v._v("的执行效率。")])])]),v._v(" "),_("h2",{attrs:{id:"aio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aio"}},[v._v("#")]),v._v(" AIO")]),v._v(" "),_("p",[v._v("异步"),_("code",[v._v("IO")]),v._v("是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。")])])}),[],!1,null,null,null);_.default=c.exports}}]);