(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{289:function(t,r,v){"use strict";v.r(r);var _=v(10),s=Object(_.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"经典排序算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#经典排序算法"}},[t._v("#")]),t._v(" 经典排序算法")]),t._v(" "),r("h2",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("动图演示"),r("OutboundLink")],1)]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("什么是稳定排序?")]),t._v(" "),r("p",[t._v("待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj（即i<j）.若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。比如int数组[1,1,1,6,4]中a[0],a[1],a[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的。")]),t._v(" "),r("p",[t._v("稳定排序算法有：插入排序，基数排序，归并排序，冒泡排序，计数排序。")]),t._v(" "),r("p",[t._v("不稳定排序算法有：快速排序，希尔排序，简单选择排序，堆排序。")])]),t._v(" "),r("p",[t._v("排序算法的复杂度说明：\n"),r("img",{attrs:{src:"/img/algorithms/array-sorting-algorithms.png",alt:"sort-overview"}})]),t._v(" "),r("h2",{attrs:{id:"冒泡排序-bubble-sort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序-bubble-sort"}},[t._v("#")]),t._v(" 冒泡排序（Bubble Sort）")]),t._v(" "),r("p",[t._v("冒泡排序就是把"),r("strong",[t._v("小的元素往前调")]),t._v("或者把"),r("strong",[t._v("大的元素往后调")]),t._v("。比较是相邻的两个元素比较，交换也发生在这两个元素之间。")]),t._v(" "),r("p",[t._v("排序流程如下：")]),t._v(" "),r("ol",[r("li",[t._v("比较"),r("strong",[t._v("相邻的元素")]),t._v("。如果第一个比第二个大，就交换他们两个。")]),t._v(" "),r("li",[t._v("对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 [1]")]),t._v(" "),r("li",[t._v("针对所有的元素重复以上的步骤，除了最后一个。")]),t._v(" "),r("li",[t._v("持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。")])]),t._v(" "),r("h2",{attrs:{id:"选择排序-selection-sort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#选择排序-selection-sort"}},[t._v("#")]),t._v(" 选择排序（Selection Sort）")]),t._v(" "),r("p",[t._v("首先在未排序序列中"),r("strong",[t._v("选择最小（大）元素")]),t._v("，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续选择最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。")]),t._v(" "),r("p",[t._v("排序流程如下：")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("初始状态：无序区为R[0..n-1]（共n个元素），有序区为空。")])]),t._v(" "),r("li",[r("p",[t._v("第1趟排序")]),t._v(" "),r("p",[t._v("设置一个变量i，让i从0至n-2循环的同时，在对比数组中元素i跟元素i+1的大小，如果R[i+1]比R[i]小，则用一个变量k来记住他的位置（即k=i+1）。等到循环结束的时候，我们应该找到了R中最小的那个数的位置了。然后进行判断，如果这个最小元素的不是R的第一个元素，就让第一个元素跟他交换一下值，使R[0..0]和R[1..n-1]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。\n……")])]),t._v(" "),r("li",[r("p",[t._v("第i趟排序")]),t._v(" "),r("p",[t._v("第i趟排序开始时，当前有序区和无序区分别为R[0..i-1]和R[i..n-1]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[0..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。")])])]),t._v(" "),r("p",[r("strong",[t._v("交换次数比冒泡排序少多了，由于交换所需CPU时间比")]),t._v("比较**所需的CPU时间多，"),r("strong",[t._v("n值较小时，选择排序比冒泡排序快")]),t._v("。")]),t._v(" "),r("h2",{attrs:{id:"插入排序-insertion-sort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#插入排序-insertion-sort"}},[t._v("#")]),t._v(" 插入排序（Insertion Sort）")]),t._v(" "),r("p",[t._v("插入排序是一种最简单的排序方法，它的基本思想是将"),r("strong",[t._v("一个记录插入到已经排好序的有序表中")]),t._v("，从而一个新的、记录数增1的有序表。")]),t._v(" "),r("h2",{attrs:{id:"希尔排序-shell-sort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序-shell-sort"}},[t._v("#")]),t._v(" 希尔排序（Shell Sort）")]),t._v(" "),r("p",[t._v("希尔排序是插入排序的一种又称“"),r("strong",[t._v("缩小增量排序")]),t._v("”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。")]),t._v(" "),r("p",[t._v("希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。")]),t._v(" "),r("p",[t._v("其排序流程如下：")]),t._v(" "),r("ol",[r("li",[t._v("选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；")]),t._v(" "),r("li",[t._v("按增量序列个数k，对序列进行k 趟排序；")]),t._v(" "),r("li",[t._v("每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。")])]),t._v(" "),r("h2",{attrs:{id:"快速排序-quick-sort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#快速排序-quick-sort"}},[t._v("#")]),t._v(" 快速排序（Quick Sort）")]),t._v(" "),r("p",[t._v("它的基本思想是："),r("strong",[t._v("通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小")]),t._v("，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。")]),t._v(" "),r("p",[t._v("快速排序算法通过多次"),r("strong",[t._v("比较")]),t._v("和"),r("strong",[t._v("交换")]),t._v("来实现排序，其排序流程如下：")]),t._v(" "),r("ol",[r("li",[t._v("首先设定一个分界值，通过该分界值将数组分成左右两部分。")]),t._v(" "),r("li",[t._v("将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。")]),t._v(" "),r("li",[t._v("然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。")]),t._v(" "),r("li",[t._v("重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。")])]),t._v(" "),r("h2",{attrs:{id:"归并排序-merge-sort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#归并排序-merge-sort"}},[t._v("#")]),t._v(" 归并排序（Merge Sort）")]),t._v(" "),r("p",[t._v("归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用"),r("strong",[t._v("分治法")]),t._v("（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；"),r("strong",[t._v("即先使每个子序列有序，再使子序列段间有序")]),t._v("。")]),t._v(" "),r("p",[t._v("归并排序流程如下：")]),t._v(" "),r("ol",[r("li",[t._v("申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列")]),t._v(" "),r("li",[t._v("设定两个指针，最初位置分别为两个已经排序序列的起始位置")]),t._v(" "),r("li",[t._v("比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置")]),t._v(" "),r("li",[t._v("重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾")])]),t._v(" "),r("p",[t._v("归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。速度仅次于快速排序，为稳定排序算法。")]),t._v(" "),r("h2",{attrs:{id:"非比较排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#非比较排序"}},[t._v("#")]),t._v(" 非比较排序")]),t._v(" "),r("ul",[r("li",[t._v("桶排序 (Bucket Sort) "),r("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/BucketSort.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("动画演示"),r("OutboundLink")],1)]),t._v(" "),r("li",[t._v("计数排序 (Counting Sort) "),r("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/CountingSort.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("动画演示"),r("OutboundLink")],1)]),t._v(" "),r("li",[t._v("基数排序(Radix Sort) "),r("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/RadixSort.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("动画演示"),r("OutboundLink")],1)]),t._v(" "),r("li",[t._v("堆排序(Heap Sort)"),r("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/HeapSort.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("动画演示"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=s.exports}}]);