(window.webpackJsonp=window.webpackJsonp||[]).push([[214],{479:function(e,v,_){"use strict";_.r(v);var o=_(10),a=Object(o.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"zab的体系结构-zookeeper原子广播协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zab的体系结构-zookeeper原子广播协议"}},[e._v("#")]),e._v(" ZAB的体系结构 - ZooKeeper原子广播协议")]),e._v(" "),v("p",[v("code",[e._v("ZAB")]),e._v("协议的全称是 "),v("code",[e._v("Zookeeper Atomic Broadcast")]),e._v(" （"),v("code",[e._v("Zookeeper")]),e._v("原子广播）。"),v("code",[e._v("Zookeeper")]),e._v(" 是通过"),v("code",[e._v("ZAB")]),e._v("协议来保证分布式系统数据最终一致性。")]),e._v(" "),v("h2",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("leader")]),e._v("和"),v("code",[e._v("follower(s)")]),e._v(" -- 在ZooKeeper集群中，一个节点是"),v("code",[e._v("leader")]),e._v("角色，其余的是"),v("code",[e._v("follower(s)")]),e._v("角色。"),v("code",[e._v("leader")]),e._v("负责接收所有来自客户端的状态变更（"),v("strong",[e._v("写请求")]),e._v("），\n并将这些变更复制到"),v("code",[e._v("leader")]),e._v("或者"),v("code",[e._v("follower(s)")]),e._v("上。"),v("strong",[e._v("读请求")]),e._v("在所有"),v("code",[e._v("follower(s)")]),e._v("和"),v("code",[e._v("leader")]),e._v("之间进行负载均衡；")]),e._v(" "),v("li",[v("code",[e._v("transactions")]),e._v(" -- 事务，即Client状态变更, 它(们)会由leader传播到它的"),v("code",[e._v("follower(s)")]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("e")]),e._v(" -- leader的epoch。epoch是由普通节点变为leader时，生成的一个整数。它应该大于任何先前leader的epoch；")]),e._v(" "),v("li",[v("code",[e._v("c")]),e._v(" -- 一个由leader生成的序数，从0开始，向上增加。它和epoch一起被用作对不断到来的Client(s)状态改变/事务进行排序；")]),e._v(" "),v("li",[v("code",[e._v("F.history")]),e._v(" -- "),v("code",[e._v("follower")]),e._v("的"),v("code",[e._v("history")]),e._v("队列。用于确保到达事务，按照它们到达的先后顺序被提交；")]),e._v(" "),v("li",[v("code",[e._v("outstanding transactions")]),e._v(" -- "),v("code",[e._v("F.history")]),e._v("中序号小于当前"),v("code",[e._v("COMMIT")]),e._v("序号的事务集合。")])]),e._v(" "),v("h2",{attrs:{id:"zab要求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zab要求"}},[e._v("#")]),e._v(" ZAB要求")]),e._v(" "),v("ol",[v("li",[e._v("复制保证\n"),v("ul",[v("li",[e._v("可靠递送 -- 如果一个事务M被一个服务器提交，它最后也会被所有服务器提交。")]),e._v(" "),v("li",[e._v("绝对顺序 -- 如果一个服务器提交的事务A先于事务B, 那么对于所有服务器，A都将先于B被提交。")]),e._v(" "),v("li",[e._v("因果顺序 -- 如果事务B发送的时间，是在B的发送者提交事务A之后，A必须是排在B之前。如果在发送B之后，某个发送者发出C ，那么C必须排在B之后。")])])]),e._v(" "),v("li",[e._v("只要过半的节点是正常的，事务就会被复制。")]),e._v(" "),v("li",[e._v("在事务复制期间，因down机错过的失败节点，恢复运行时应能再次获得。")])]),e._v(" "),v("h2",{attrs:{id:"zab-实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zab-实现"}},[e._v("#")]),e._v(" ZAB 实现")]),e._v(" "),v("p",[e._v("客户端可以从任何ZooKeeper节点发起"),v("strong",[e._v("读操作")]),e._v("，对任何ZooKeeper节点执行"),v("strong",[e._v("写操作")]),e._v("，状态变更会被先转发到leader节点。")]),e._v(" "),v("p",[e._v("ZooKeeper使用一种"),v("code",[e._v("二阶段提交协议")]),e._v("的变体，复制事务到"),v("code",[e._v("follower(s)")]),e._v("。当"),v("code",[e._v("leader")]),e._v("接收到来自某个客户端的状态更新时，它用序数"),v("code",[e._v("c")]),e._v("(32位)和leader epoch "),v("code",[e._v("e")]),e._v("(32位)生成一个事务("),v("code",[e._v("Zxid")]),e._v(")，并将其发送给所有"),v("code",[e._v("follower(s)")]),e._v("。")]),e._v(" "),v("p",[v("code",[e._v("follower")]),e._v("接收后，会将"),v("code",[e._v("transactions")]),e._v("添加到它的"),v("code",[e._v("F.history")]),e._v("队列中，并向"),v("code",[e._v("leader")]),e._v("回送"),v("code",[e._v("ACK")]),e._v("。当leader收到过半的的ACK时，它就会发出事务"),v("code",[e._v("COMMIT")]),e._v("。接收到提交的"),v("code",[e._v("follower(s)")]),e._v("就会"),v("code",[e._v("COMMIT")]),e._v("该事务，除非"),v("code",[e._v("c")]),e._v("值大于它"),v("code",[e._v("F.history")]),e._v("队列里的所用序号。这时，它会先等待接收先前事务("),v("code",[e._v("outstanding transaction(s)")]),e._v(")的提交操作，然后再执行该提交。")]),e._v(" "),v("p",[v("img",{attrs:{src:"/img/zk/zabp.png",alt:"ZAB协议"}})]),e._v(" "),v("p",[e._v("一旦leader崩溃，节点间会执行一个"),v("strong",[e._v("崩溃恢复协议")]),e._v("，以确保以下两点：")]),e._v(" "),v("ul",[v("li",[e._v("恢复正常服务之前，节点间对共同状态的一致性达成共识；")]),e._v(" "),v("li",[e._v("找出一个新"),v("code",[e._v("leader")]),e._v("来广播状态更新。一个节点要行使"),v("code",[e._v("leader")]),e._v("角色，必须获得"),v("strong",[e._v("法定人数(quorum)数量")]),e._v("的节点支持。现实中，由于存在节点的崩溃、恢复往复；一段时间里，可能出现多位leader的更迭，甚至是同一节点多次成为leader的情形。")])]),e._v(" "),v("p",[e._v("节点的生命周期：每个节点要么一次执行这个协议的一个完整循环；要么循环被突然中断，回到Phase 0, 再开始一个新的循环。")]),e._v(" "),v("ul",[v("li",[e._v("Phase 0 -- leader选举")]),e._v(" "),v("li",[e._v("Phase 1 -- 发现")]),e._v(" "),v("li",[e._v("Phase 2 -- 同步")]),e._v(" "),v("li",[e._v("Phase 3 -- 广播")])]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("注:")]),e._v(" "),v("p",[e._v("Phase 1 和 Phase 2，对于确保所有节点上状态的一致性很重要，特别是在节点从崩溃恢复时。")])]),e._v(" "),v("h3",{attrs:{id:"phase-0-leader选举"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#phase-0-leader选举"}},[e._v("#")]),e._v(" Phase 0 -- leader选举")]),e._v(" "),v("p",[e._v("节点在该阶段运行初始化，状态为election。leader选举协议不必多特别，只要可结束、高概率，能选出一个可用节点，选举节点数达到"),v("strong",[e._v("法定人数(quorum)数量")]),e._v("就行。leader选举算法结束后，节点会将它的选举结果保存到本地内存。")]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("大致为：")]),e._v(" "),v("p",[e._v("如果节点p投票给p0, 那么p0就称为p的预期leader；如果节点投票给它自己，它的状态应设为leading，否则就设为following。顺便提一下，只有到达Phase 3的开始，这里选出的预期leader才可能变成真正的leader，并成为主处理节点。")])]),e._v(" "),v("h3",{attrs:{id:"phase-1-发现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#phase-1-发现"}},[e._v("#")]),e._v(" Phase 1 -- 发现")]),e._v(" "),v("p",[e._v("在这个阶段，"),v("code",[e._v("follower(s)")]),e._v("和它们的预期"),v("code",[e._v("leader")]),e._v("保持通讯，以便"),v("code",[e._v("leader")]),e._v("能够收集有关"),v("code",[e._v("follower(s)")]),e._v("最近接受的事务信息。这个阶段的目的，是为了在**法定数量(quorum)**节点内，发现尽可能多的已接受事务更新序号，以便创建一个新的"),v("code",[e._v("epoch")]),e._v(",以防先前的"),v("code",[e._v("leader")]),e._v("再提交新的事务。")]),e._v(" "),v("p",[e._v("理论上，具有"),v("code",[e._v("法定人数(quorum)")]),e._v("数量的"),v("code",[e._v("follower(s)")]),e._v("都拥有前任"),v("code",[e._v("leader")]),e._v("所有已接受状态变更的信息，于是在当前"),v("code",[e._v("法定节点数(quorum)")]),e._v("中，至少有一个"),v("code",[e._v("follower")]),e._v("，在"),v("code",[e._v("F.history")]),e._v("队列中拥有前任"),v("code",[e._v("leader")]),e._v("所有已接受的状态变更。这就意味着，这位新"),v("code",[e._v("leader")]),e._v("同样可以获得这些信息。")]),e._v(" "),v("h3",{attrs:{id:"phase-2-同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#phase-2-同步"}},[e._v("#")]),e._v(" Phase 2 -- 同步")]),e._v(" "),v("p",[e._v("同步阶段对该协议的发现阶段做出总结，即"),v("code",[e._v("leader")]),e._v("将用发现阶段获得的变更历史，对集群节点进行同步操作。"),v("code",[e._v("leader")]),e._v("会和"),v("code",[e._v("follower(s)")]),e._v("进行通信，并从自己"),v("code",[e._v("F.history")]),e._v("队列里发出事务。如果"),v("code",[e._v("follower(s)")]),e._v("的"),v("code",[e._v("F.history")]),e._v("滞后于"),v("code",[e._v("leader")]),e._v("，"),v("code",[e._v("follower(s)")]),e._v("就会回复"),v("code",[e._v("ACK")]),e._v("； 当"),v("code",[e._v("leader")]),e._v("看到来自"),v("code",[e._v("法定节点数(quorum)")]),e._v("的"),v("code",[e._v("ACK")]),e._v(",它就会发出提交信息给它们。此时，"),v("code",[e._v("leader")]),e._v("角色真正成立，不再是"),v("code",[e._v("预期leader")]),e._v("了。")]),e._v(" "),v("h3",{attrs:{id:"phase-3-广播"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#phase-3-广播"}},[e._v("#")]),e._v(" Phase 3 -- 广播")]),e._v(" "),v("p",[e._v("现在开始，如果没有节点发生崩溃，它们将永远呆在该阶段，收到ZooKeeper Client发出的写请求，就执行事务广播。")]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("注：")]),e._v(" "),v("p",[e._v("对于失败检测，ZAB采用的是在"),v("code",[e._v("leader")]),e._v("和"),v("code",[e._v("follower(s)")]),e._v("间周期性的发送心跳("),v("code",[e._v("heartbeat")]),e._v(")信息。如果"),v("code",[e._v("leader")]),e._v("在规定时间内，没有收到"),v("code",[e._v("法定数量(quorum)")]),e._v("节点的心跳，它就会放弃领导权，并转到"),v("strong",[e._v("选举状态(Phase 0)")]),e._v("；而如果"),v("code",[e._v("follower")]),e._v("超时未收到来自"),v("code",[e._v("leader")]),e._v("的心跳(heartbeat)也会转入"),v("code",[e._v("leader")]),e._v("选举阶段。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);