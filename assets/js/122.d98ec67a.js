(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{387:function(v,a,_){"use strict";_.r(a);var t=_(10),r=Object(t.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"jvm-垃圾回收-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm-垃圾回收-gc"}},[v._v("#")]),v._v(" JVM 垃圾回收(GC)")]),v._v(" "),a("h2",{attrs:{id:"垃圾收集算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法"}},[v._v("#")]),v._v(" 垃圾收集算法")]),v._v(" "),a("p",[a("img",{attrs:{src:"/img/java/jvm-gc.png",alt:"gc"}})]),v._v(" "),a("ol",[a("li",[v._v("新生代 使用"),a("strong",[v._v("复制算法")])]),v._v(" "),a("li",[v._v("老生代 使用"),a("strong",[v._v("标记-整理")]),v._v("、"),a("strong",[v._v("标记-清除")])])]),v._v(" "),a("h3",{attrs:{id:"标记-清除算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法"}},[v._v("#")]),v._v(" 标记-清除算法")]),v._v(" "),a("p",[v._v("该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：")]),v._v(" "),a("ul",[a("li",[v._v("效率问题 ：标记和清除两个过程的效率都不高。")]),v._v(" "),a("li",[a("strong",[v._v("空间问题（标记清除后会产生大量不连续的碎片）")]),v._v("：空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。")])]),v._v(" "),a("h3",{attrs:{id:"复制算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[v._v("#")]),v._v(" 复制算法")]),v._v(" "),a("p",[v._v("为了解决效率问题，“复制”收集算法出现了。它可以将内存分为"),a("strong",[v._v("大小相同的两块")]),v._v("，每次使用其中的一块。当这一块的内存使用完后，就将还"),a("strong",[v._v("存活的对象复制到另一块去")]),v._v("，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。")]),v._v(" "),a("h3",{attrs:{id:"标记-整理算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理算法"}},[v._v("#")]),v._v(" 标记-整理算法")]),v._v(" "),a("p",[v._v("复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，\n以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不直接选用“复制算法”。")]),v._v(" "),a("p",[v._v('根据老年代的特点，使用"标记-整理算法",标记的过程仍然与“标记-清除”算法一样，但后续步骤不是直接清除，而是让所有的存活对象都向一端移动，\n然后直接清理掉端边界以外的内存。')]),v._v(" "),a("h3",{attrs:{id:"分代收集算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分代收集算法"}},[v._v("#")]),v._v(" 分代收集算法")]),v._v(" "),a("p",[v._v("当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("比如在新生代中，每次收集都会有大量对象死去，所以可以选择”复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集")]),v._v("。")]),v._v(" "),a("li",[a("strong",[v._v("而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集")]),v._v("。")])]),v._v(" "),a("h2",{attrs:{id:"如何判断对象是否死亡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何判断对象是否死亡"}},[v._v("#")]),v._v(" 如何判断对象是否死亡")]),v._v(" "),a("ol",[a("li",[v._v("引用计数法（弃用）：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\n"),a("ul",[a("li",[v._v("每当有一个地方引用它，计数器就加 1；")]),v._v(" "),a("li",[v._v("当引用失效，计数器就减 1；")]),v._v(" "),a("li",[v._v("任何时候计数器为 0 的对象就是不可能再被使用的。")])])]),v._v(" "),a("li",[v._v("可达性分析算法：这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的")])]),v._v(" "),a("p",[v._v("在Java中，可作为 GC Roots 的对象包括下面几种")]),v._v(" "),a("ol",[a("li",[v._v("虚拟机栈(栈帧中的本地变量表)中引用的对象")]),v._v(" "),a("li",[v._v("本地方法栈(Native 方法)中引用的对象")]),v._v(" "),a("li",[v._v("方法区中类静态属性引用的对象")]),v._v(" "),a("li",[v._v("方法区中常量引用的对象")])]),v._v(" "),a("h2",{attrs:{id:"引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[v._v("#")]),v._v(" 引用")]),v._v(" "),a("ol",[a("li",[v._v("强引用：“Object ojb = new Object” 这类的引用，只要强引用还存在，GC永远不会回收被引用的对象。")]),v._v(" "),a("li",[v._v("软引用：描述一些还有用但并非必需的对象，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。")]),v._v(" "),a("li",[v._v("弱引用：也是描述一些还有用但并非必需的对象，但是它的强度比软引用更弱一些，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存，例如：ThreadLocal。")]),v._v(" "),a("li",[v._v("虚引用：虚引用并不会决定对象的生命周期，唯一的目的就是能在这个对象被GC时，收到一个系统通知。")])]),v._v(" "),a("h2",{attrs:{id:"jvm调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优"}},[v._v("#")]),v._v(" JVM调优 👍")]),v._v(" "),a("ol",[a("li",[v._v("追求吞吐量: Parallel Scavenge + Parallel Old （PS + PO）")]),v._v(" "),a("li",[a("strong",[v._v("追求响应时间")]),v._v(": 网站相关 （JDK 1.8之后 G1,之前可以ParNew + CMS + Serial Old）")])]),v._v(" "),a("h3",{attrs:{id:"cpu高负荷排查流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu高负荷排查流程"}},[v._v("#")]),v._v(" CPU高负荷排查流程")]),v._v(" "),a("ol",[a("li",[v._v("系统CPU经常100%，如何调优？(面试高频) CPU100%那么一定有线程在占用系统资源，找出哪个进程cpu高（top）该进程中的哪个线程cpu高（top -Hp）导出该线程的堆栈 (jstack)查找哪个方法（栈帧）消耗时间 (jstack)工作线程占比高 | 垃圾回收线程占比高")]),v._v(" "),a("li",[v._v("系统内存飙高，如何查找问题？（面试高频）导出堆内存 (jmap)分析 (jhat jvisualvm mat jprofiler ... )")]),v._v(" "),a("li",[v._v("如何监控JVM jstat jvisualvm jprofiler arthas top.")])]),v._v(" "),a("h3",{attrs:{id:"jvm调优案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优案例"}},[v._v("#")]),v._v(" JVM调优案例")]),v._v(" "),a("p",[v._v("服务器配置：8 核 CPU, 8G MEM, JDK 1.6.X\n参数方案：-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC")]),v._v(" "),a("ol",[a("li",[v._v("-Xmx 与 -Xms 相同以避免JVM反复重新申请内存。")]),v._v(" "),a("li",[v._v("-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。")]),v._v(" "),a("li",[v._v("-Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。")]),v._v(" "),a("li",[v._v("-XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。")]),v._v(" "),a("li",[v._v("-XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);