(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{435:function(e,s,v){"use strict";v.r(s);var a=v(10),_=Object(a.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"redis-内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-内存"}},[e._v("#")]),e._v(" Redis 内存")]),e._v(" "),s("p",[s("code",[e._v("Redis")]),e._v("的所有的数据都是存在了内存中的。换句话说，"),s("code",[e._v("Redis")]),e._v("是一种内存数据库，将数据保存在内存中，读写效率要比传统的将数据保存在磁盘上的数据库要快很多。")]),e._v(" "),s("p",[s("code",[e._v("Redis")]),e._v("通过一个叫做"),s("strong",[e._v("过期字典")]),e._v("（可以看作是"),s("code",[e._v("hash")]),e._v("表）来保存数据过期的时间。过期字典的键指向"),s("code",[e._v("Redis")]),e._v("数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了"),s("code",[e._v("key")]),e._v("所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。")]),e._v(" "),s("p",[s("img",{attrs:{src:"/img/redis/redis%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4.png",alt:"redis过期时间"}})]),e._v(" "),s("p",[e._v("过期字典是存储在"),s("code",[e._v("redisDb")]),e._v("这个结构里的：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("typedef struct redisDb {\n...\n\n    dict *dict;     //数据库键空间,保存着数据库中所有键值对\n    dict *expires   // 过期字典,保存着键的过期时间\n    ...\n} redisDb;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("h2",{attrs:{id:"redis-内存淘汰机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-内存淘汰机制"}},[e._v("#")]),e._v(" Redis 内存淘汰机制")]),e._v(" "),s("p",[e._v("Redis 提供 6 种数据淘汰策略：")]),e._v(" "),s("ol",[s("li",[s("strong",[e._v("volatile-lru（least recently used）")]),e._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰")]),e._v(" "),s("li",[s("strong",[e._v("volatile-ttl")]),e._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰")]),e._v(" "),s("li",[s("strong",[e._v("volatile-random")]),e._v("：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰")]),e._v(" "),s("li",[s("strong",[e._v("allkeys-lru（least recently used）")]),e._v("：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）")]),e._v(" "),s("li",[s("strong",[e._v("allkeys-random")]),e._v("：从数据集（server.db[i].dict）中任意选择数据淘汰")]),e._v(" "),s("li",[s("strong",[e._v("no-eviction")]),e._v("：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！")])]),e._v(" "),s("p",[e._v("4.0 版本后增加以下两种：")]),e._v(" "),s("ol",{attrs:{start:"7"}},[s("li",[s("strong",[e._v("volatile-lfu（least frequently used）")]),e._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰")]),e._v(" "),s("li",[s("strong",[e._v("allkeys-lfu（least frequently used）")]),e._v("：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key")])]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?")]),e._v(" "),s("ol",[s("li",[e._v("保留热点数据：对于保留 Redis 热点数据来说，我们可以使用 Redis 的内存淘汰策略来实现，可以使用"),s("strong",[e._v("allkeys-lru")]),e._v("淘汰策略，该淘汰策略是从 Redis 的数据中挑选最近最少使用的数据删除，这样频繁被访问的数据就可以保留下来了。")]),e._v(" "),s("li",[e._v("保证 Redis 只存20w的数据：1个中文占2个字节，假如1条数据有100个中文，则1条数据占200字节，20w数据 乘以 200字节 等于 4000 字节（大概等于38M）;所以要保证能存20w数据，Redis 需要"),s("strong",[e._v("38M")]),e._v("的内存。")])])]),e._v(" "),s("h2",{attrs:{id:"过期删除机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过期删除机制"}},[e._v("#")]),e._v(" 过期删除机制")]),e._v(" "),s("p",[e._v("常用的过期数据的删除策略就两个：")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("惰性删除")]),e._v(" ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。")]),e._v(" "),s("li",[s("strong",[e._v("定期删除")]),e._v(" ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。")])]),e._v(" "),s("p",[s("code",[e._v("Redis")]),e._v("采用的是 "),s("strong",[e._v("定期删除+惰性/懒汉式删除")]),e._v("，两者配合使用。")]),e._v(" "),s("blockquote",[s("p",[e._v("redis 主从模式下，惰性删除也只在"),s("code",[e._v("master")]),e._v("上生效，"),s("code",[e._v("slave")]),e._v("上是不生效的。"),s("code",[e._v("slave")]),e._v("上过期的"),s("code",[e._v("key")]),e._v("会依赖"),s("code",[e._v("master")]),e._v("发过来的"),s("code",[e._v("DEL")]),e._v("命令来删除")])]),e._v(" "),s("h2",{attrs:{id:"数据持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据持久化"}},[e._v("#")]),e._v(" 数据持久化")]),e._v(" "),s("h3",{attrs:{id:"rdb-redis-database"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb-redis-database"}},[e._v("#")]),e._v(" RDB（Redis DataBase）")]),e._v(" "),s("p",[s("code",[e._v("RDB")]),e._v("方式也叫快照方式，这种方式会在一定的触发时机下，将当前"),s("code",[e._v("redis")]),e._v("的内存快照保存到磁盘上的"),s("code",[e._v("dump.rdb")]),e._v("文件中。这个过程中，主要执行一个命令"),s("code",[e._v("bgsave")]),e._v("。")]),e._v(" "),s("p",[e._v("非常适用于备份，全量复制等场景，但是无法做到实时持久化/秒级持久化。")]),e._v(" "),s("p",[e._v("快照持久化是 Redis "),s("strong",[e._v("默认采用的持久化方式")]),e._v("，在 redis.conf 配置文件中默认有此下配置：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("ul",[s("li",[e._v("save 命令是一个同步操作，当客户端向服务器发送 save 命令请求进行持久化时，服务器会阻塞 save 命令之后的其他客户端的请求，直到数据同步完成。")]),e._v(" "),s("li",[e._v("bgsave 命令是一个异步操作，当客户端发出 bgsave 命令时，Redis 服务器主进程会 fork 一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求，子进程会在数据保存到 rdb 文件后退出。")])]),e._v(" "),s("h3",{attrs:{id:"aof-append-only-file"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof-append-only-file"}},[e._v("#")]),e._v(" AOF（Append Only File）")]),e._v(" "),s("p",[e._v("在"),s("code",[e._v("Redis")]),e._v("的配置文件中存在三种不同的"),s("code",[e._v("AOF")]),e._v("持久化方式，它们分别是：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度\nappendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘\nappendfsync no        #让操作系统决定何时进行同步\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[s("code",[e._v("AOF")]),e._v("的"),s("code",[e._v("appendfsync")]),e._v("触发机制是上面配置的三个参数决定的："),s("code",[e._v("no")]),e._v("、"),s("code",[e._v("always")]),e._v("、"),s("code",[e._v("everysec")]),e._v("。\n可以根据对性能和持久化的实时性要求，具体配置。如果不知道哪种合适，就使用默认的"),s("code",[e._v("everysec")]),e._v("，这样即使出现系统崩溃，最多只会丢失"),s("code",[e._v("1s")]),e._v("之内产生的数据。")]),e._v(" "),s("p",[s("code",[e._v("AOF")]),e._v("文件远大于"),s("code",[e._v("RDB")]),e._v("文件，数据恢复速度比"),s("code",[e._v("rdb")]),e._v("慢。")]),e._v(" "),s("h3",{attrs:{id:"写时复制-cow-copy-on-write-机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#写时复制-cow-copy-on-write-机制"}},[e._v("#")]),e._v(" 写时复制 COW (Copy On Write)机制")]),e._v(" "),s("ol",[s("li",[e._v("Redis使用操作系统的多进程写时复制(Copy On Write)机制来实现快照的持久化，在持久化过程中调用glibc(Linux下的C函数库)的函数fork()产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端的读写请求。")]),e._v(" "),s("li",[e._v('如果主线程收到的客户端的读写请求，需要修改某块数据，那么这块数据就会被复制一份到内存，生成该数据的副本，主进程在该副本上进行修改操作。所以即使对某个数据进行了修改，Redis持久化到RDB中的数据也是未修改的数据，这也是把RDB文件称为"快照"文件的原因，子进程所看到的数据在它被创建的一瞬间就固定下来了，父进程修改的某个数据只是该数据的复制品。')])]),e._v(" "),s("h3",{attrs:{id:"aof-文件过大怎么办"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof-文件过大怎么办"}},[e._v("#")]),e._v(" AOF 文件过大怎么办？")]),e._v(" "),s("p",[e._v("执行"),s("code",[e._v("BGREWRITEAOF")]),e._v("命令对"),s("code",[e._v("redis")]),e._v("的"),s("code",[e._v("AOF")]),e._v("进行"),s("strong",[e._v("重写（rewrite）机制")])]),e._v(" "),s("ol",[s("li",[e._v("随着"),s("code",[e._v("AOF")]),e._v("文件越来越大，里面会有大部分是重复命令或者可以合并的命令")]),e._v(" "),s("li",[e._v("减少"),s("code",[e._v("AOF")]),e._v("日志大小，减少内存占用，加快数据库恢复时间")])]),e._v(" "),s("hr"),e._v(" "),s("p",[s("strong",[e._v("参考文档")])]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://redis.io/topics/memory-optimization",target:"_blank",rel:"noopener noreferrer"}},[e._v("内存优化"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=_.exports}}]);