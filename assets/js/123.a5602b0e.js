(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{394:function(o,v,_){"use strict";_.r(v);var r=_(10),t=Object(r.a)({},(function(){var o=this,v=o._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[v("h1",{attrs:{id:"kafka"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[o._v("#")]),o._v(" kafka")]),o._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[o._v("特别提示")]),o._v(" "),v("p",[o._v("本文基于 "),v("code",[o._v("kafka 2.5.0")]),o._v(" 介绍实际开发中常用的一些概念，非常详细的介绍，请参考"),v("a",{attrs:{href:"http://kafka.apache.org/intro",target:"_blank",rel:"noopener noreferrer"}},[o._v("官方文档"),v("OutboundLink")],1)])]),o._v(" "),v("h2",{attrs:{id:"术语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#术语"}},[o._v("#")]),o._v(" 术语")]),o._v(" "),v("ul",[v("li",[v("strong",[o._v("Broker")]),o._v(" : kafka 集群包含一个或多个服务器，这种服务器被称为 broker")]),o._v(" "),v("li",[v("strong",[o._v("Topic")]),o._v(" : 每条发布到 kafka 集群的消息都有一个类别，这个类别被称为 "),v("strong",[o._v("Topic")]),o._v("（物理上不同 "),v("strong",[o._v("Topic")]),o._v(" 的消息分开存储，逻辑上一个 "),v("strong",[o._v("Topic")]),o._v(" 的消息虽然保存于一个或多个 "),v("strong",[o._v("broker")]),o._v(" 上，但用户只需指定消息的 "),v("strong",[o._v("Topic")]),o._v(" 即可生产或消费数据，不必关心数据存于何处）")]),o._v(" "),v("li",[v("strong",[o._v("Partition")]),o._v(" : 是物理上的概念，每个 Topic 包含一个或多个 Partition.")]),o._v(" "),v("li",[v("strong",[o._v("Producer")]),o._v(" : 负责发布消息到 kafka broker")]),o._v(" "),v("li",[v("strong",[o._v("Consumer")]),o._v(" : 消息消费者，向 kafka broker 读取消息的客户端。")]),o._v(" "),v("li",[v("strong",[o._v("Consumer Group")]),o._v(" : 每个 Consumer 属于一个特定的 "),v("strong",[o._v("Consumer Group")]),o._v("（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）")])]),o._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[o._v("Kafka的记录（消息）")]),o._v(" "),v("p",[o._v("每条记录都包含 一个 key, 一个 value, 一个 timestamp.")])]),o._v(" "),v("h2",{attrs:{id:"kafka-拓扑结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka-拓扑结构"}},[o._v("#")]),o._v(" kafka 拓扑结构")]),o._v(" "),v("p",[v("img",{attrs:{src:"/img/kafka/kafka.png",alt:"topic"}})]),o._v(" "),v("p",[o._v("如上图所示，一个典型的 kafka 集群中包含：")]),o._v(" "),v("ul",[v("li",[o._v("若干 Producer（可以是 web 前端产生的 Page View，或者是服务器日志，系统 CPU、Memory 等）")]),o._v(" "),v("li",[o._v("若干 broker（kafka 支持水平扩展，一般 broker 数量越多，集群吞吐率越高）")]),o._v(" "),v("li",[o._v("若干 Consumer Group")]),o._v(" "),v("li",[o._v("一个 Zookeeper 集群")])]),o._v(" "),v("p",[o._v("kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。")]),o._v(" "),v("p",[o._v("Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。")]),o._v(" "),v("h2",{attrs:{id:"topics-and-logs"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#topics-and-logs"}},[o._v("#")]),o._v(" Topics and Logs")]),o._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[o._v("(阿里云)Topic的取值：")]),o._v(" "),v("ul",[v("li",[o._v("只能包含字母、数字、下划线（_）和短划线（-）")]),o._v(" "),v("li",[o._v("长度限制为3~64字符")]),o._v(" "),v("li",[o._v("Topic名称一旦创建，将无法修改")])])]),o._v(" "),v("p",[o._v("kafka 中的 Topic 始终是多用户的；也就是说，一个主题可以有零个，一个或多个消费者来订阅或写入该 Topic 的数据。")]),o._v(" "),v("p",[o._v("对于每个 Topic ，Kafka集群 都会维护一个分区日志，如下所示：")]),o._v(" "),v("p",[v("img",{attrs:{src:"/img/kafka/log_anatomy.png",alt:"topic"}})]),o._v(" "),v("p",[o._v("每个 Partition 都是有序的, 不变的记录队列， 新提交的记录顺序追加到这个队列中。 每个 Partition 中的记录都会分配一个 offset (偏移量) 的顺序 ID ，该 ID 唯一地标识 Partition 中的每个记录。")]),o._v(" "),v("p",[o._v("Kafka集群根据配置持久保存所有已发布的记录（无论是否已使用它们）。例如：如果保留策略设置为两天，则在发布记录后的两天内，该记录都可被使用，之后将被丢弃以释放空间。"),v("strong",[o._v("Kafka的性能相对于数据大小实际上是不变的，因此长时间存储数据不是问题。")])]),o._v(" "),v("p",[v("img",{attrs:{src:"/img/kafka/log_consumer.png",alt:"topic"}})]),o._v(" "),v("p",[o._v("实际上，基于每个 Consumer 保留的唯一元数据是该 Consumer 在记录中的 offset(偏移量或位置)。此 offset 由使用者控制：通常使用者在读取记录时会顺序的移动其 offset，但实际上，由于位置是有使用者控制的，因此它可以按喜欢的任何顺序使用记录。例如，使用者重置到较早的 offset 重新处理过去的数据，或者跳到最近的记录并从“现在”开始使用。")]),o._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[o._v("Kafka中的Topic为什么要进行分区?")]),o._v(" "),v("blockquote",[v("p",[o._v("为了性能考虑，方便水平扩展")])]),o._v(" "),v("p",[o._v("Kafka 中的"),v("strong",[o._v("Topic")]),o._v("是逻辑概念，而"),v("strong",[o._v("Partition")]),o._v("是物理概念，对用户是透明的。用户只需指定消息的"),v("strong",[o._v("Topic")]),o._v("即可生产或消费数据，不必关心数据存于何处。")]),o._v(" "),v("p",[o._v("如果"),v("strong",[o._v("Topic")]),o._v("内的消息只能存在一个"),v("strong",[o._v("Broker")]),o._v(",那么"),v("strong",[o._v("Broker")]),o._v("就会成为瓶颈，无法做到水平扩展。所以把"),v("strong",[o._v("Topic")]),o._v("内的消息分布到集群就是并且引入"),v("strong",[o._v("Partition")]),o._v("就是为了解决水平扩展问题的。")]),o._v(" "),v("p",[o._v("从上我们知道每个 Partition 都是有序的, 不变的记录队列，新提交的记录顺序追加到这个队列中。在物理上，每个 Partition 对应一个文件夹。一个"),v("strong",[o._v("Broker")]),o._v("上可以存放多个"),v("strong",[o._v("Partition")]),o._v("。\n这样 Producer 可以将数据发送给多个"),v("strong",[o._v("Broker")]),o._v("上的多个"),v("strong",[o._v("Partition")]),o._v("，"),v("strong",[o._v("Consumer")]),o._v("也可以"),v("strong",[o._v("并行")]),o._v("从多个"),v("strong",[o._v("Broker")]),o._v("上的不同"),v("strong",[o._v("Partition")]),o._v("上读数据，实现了水平扩展。")])]),o._v(" "),v("h2",{attrs:{id:"producers"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#producers"}},[o._v("#")]),o._v(" Producers")]),o._v(" "),v("p",[o._v("Producer 将数据发布到指定的主题。你可以简单地为负载均衡而采取循环方式完成此操作，也可以根据某些规则（例如基于记录的KEY）来完成此操作。")]),o._v(" "),v("h2",{attrs:{id:"consumers"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#consumers"}},[o._v("#")]),o._v(" Consumers 🎉")]),o._v(" "),v("p",[v("strong",[o._v("Consumer")]),o._v("使用group name 标记自己, 并且发布到"),v("strong",[o._v("Topic")]),o._v("的每条记录都会传递到每个订阅"),v("strong",[o._v("Consumer Group")]),o._v("中的一个 Consumer 实例。")]),o._v(" "),v("p",[o._v("如果所有的 Consumer 实例拥有相同的"),v("strong",[o._v("Consumer Group")]),o._v("，那么记录会均衡的分配到 Consumer 实例中。")]),o._v(" "),v("p",[o._v("如果所有的 Consumer 实例拥有不同的"),v("strong",[o._v("Consumer Group")]),o._v("，那么每天记录都会广播到所有的 Consumer进程中。")]),o._v(" "),v("p",[v("img",{attrs:{src:"/img/kafka/consumer-groups.png",alt:"consumer-groups"}})]),o._v(" "),v("p",[o._v("如上图所示：一个Kafka集群拥有两台服务器、4个"),v("strong",[o._v("Partition(P0-P3)")]),o._v("、2个"),v("strong",[o._v("Consumer Group")]),o._v("，"),v("strong",[o._v("Consumer Group A")]),o._v("有2个消费实例，"),v("strong",[o._v("Consumer Group A")]),o._v("有4个消费实例，")]),o._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[o._v("总结")]),o._v(" "),v("p",[o._v("同一 "),v("strong",[o._v("Topic")]),o._v(" 的一条消息只能被同一个 "),v("strong",[o._v("Consumer Group")]),o._v(" 内的一个 Consumer 消费，但多个 "),v("strong",[o._v("Consumer Group")]),o._v(" 可同时消费这一消息。")])]),o._v(" "),v("p",[o._v("在Kafka中，"),v("code",[o._v("Consumer Rebalance")]),o._v(" 算法如下：")]),o._v(" "),v("ol",[v("li",[v("strong",[o._v("将目标 "),v("code",[o._v("topic")]),o._v(" 下的所有 "),v("code",[o._v("partition")]),o._v(" 排序，存于"),v("code",[o._v("PT")])])]),o._v(" "),v("li",[v("strong",[o._v("对某Consumer Group下所有 "),v("code",[o._v("Consumer")]),o._v(" 排序，存于 "),v("code",[o._v("CG")]),o._v("，第 "),v("code",[o._v("i")]),o._v(" "),v("code",[o._v("个consumer")]),o._v(" 记为 "),v("code",[o._v("Ci")])])]),o._v(" "),v("li",[v("strong",[v("code",[o._v("N = size(PT)/size(CG)")]),o._v("，向上取整")])]),o._v(" "),v("li",[v("strong",[o._v("解除 "),v("code",[o._v("Ci")]),o._v(" 对原来分配的 "),v("code",[o._v("partition")]),o._v(" 的消费权（"),v("code",[o._v("i")]),o._v("从"),v("code",[o._v("0")]),o._v("开始）")])]),o._v(" "),v("li",[v("strong",[o._v("将第 "),v("code",[o._v("i*N")]),o._v(" 到 "),v("code",[o._v("(i+1)*N-1")]),o._v(" 个 "),v("code",[o._v("partition")]),o._v(" 分配给 "),v("code",[o._v("Ci")])])])]),o._v(" "),v("p",[o._v("例如：")]),o._v(" "),v("ul",[v("li",[o._v("有4个partition，2个consumer，则会把p0~p1分配给c0,p2~p3分配给c1；")]),o._v(" "),v("li",[o._v("有4个partition，3个consumer，则会把p0~p1分配给c0,p2~p3分配给c1，c2未分配；")]),o._v(" "),v("li",[o._v("有4个partition，4个consumer，则会把p0分配给c0,p1分配给c1，p2分配给c2，p3分配给c3；")])]),o._v(" "),v("p",[v("code",[o._v("Consumer rebalance")]),o._v(" 的控制策略是由每一个 "),v("code",[o._v("Consumer")]),o._v(" 通过 "),v("code",[o._v("Zookeeper")]),o._v(" 完成的。具体的控制方式如下：")]),o._v(" "),v("ol",[v("li",[o._v("在 "),v("code",[o._v("/consumers/[consumer-group]/")]),o._v(" 下注册"),v("code",[o._v("id")])]),o._v(" "),v("li",[o._v("设置对 "),v("code",[o._v("/consumers/[consumer-group]")]),o._v(" 的"),v("code",[o._v("watcher")])]),o._v(" "),v("li",[o._v("设置对 "),v("code",[o._v("/brokers/ids")]),o._v(" 的"),v("code",[o._v("watcher")])]),o._v(" "),v("li",[v("code",[o._v("zk")]),o._v(" 下设置 "),v("code",[o._v("watcher")]),o._v(" 的路径节点更改，触发 "),v("code",[o._v("Consumer rebalance")])])]),o._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[o._v("羊群效应理论")]),o._v(" "),v("p",[o._v("任何"),v("code",[o._v("broker")]),o._v("或者"),v("code",[o._v("consumer")]),o._v("的增减都会触发所有的"),v("code",[o._v("consumer")]),o._v("的"),v("code",[o._v("rebalance")])])]),o._v(" "),v("p",[v("code",[o._v("Kafka")]),o._v(" 仅仅提供 一个"),v("strong",[o._v("Partition")]),o._v(" 内的记录顺序，而不能提供在同一 "),v("strong",[o._v("Topic")]),o._v("下不同 "),v("strong",[o._v("Partition")]),o._v("的顺序。当你需要同一 "),v("strong",[o._v("Topic")]),o._v("的记录是顺序的，则可以使用一个"),v("strong",[o._v("Partition")]),o._v("的"),v("strong",[o._v("Topic")]),o._v("来实现：")]),o._v(" "),v("ul",[v("li",[o._v("发送消息到只有一个"),v("strong",[o._v("Partition")]),o._v("的"),v("strong",[o._v("Topic")])]),o._v(" "),v("li",[o._v("发送消息指定"),v("strong",[o._v("Partition")])]),o._v(" "),v("li",[o._v("发送消息的"),v("strong",[o._v("KEY相同")]),o._v("（消息KEY相同，那么消息提交的到"),v("strong",[o._v("Partition")]),o._v("是相同的）")])]),o._v(" "),v("h2",{attrs:{id:"kafka为什么高吞吐量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka为什么高吞吐量"}},[o._v("#")]),o._v(" Kafka为什么高吞吐量")]),o._v(" "),v("ol",[v("li",[o._v("顺序读写")]),o._v(" "),v("li",[o._v("零拷贝")]),o._v(" "),v("li",[o._v("DMA(Direct Memory Access)")])]),o._v(" "),v("h2",{attrs:{id:"延伸阅读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#延伸阅读"}},[o._v("#")]),o._v(" 延伸阅读")]),o._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html",target:"_blank",rel:"noopener noreferrer"}},[o._v("Kafka文件存储机制那些事"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=t.exports}}]);