(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{426:function(_,v,t){"use strict";t.r(v);var s=t(10),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[_._v("#")]),_._v(" 概述")]),_._v(" "),v("h2",{attrs:{id:"tcp三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[_._v("#")]),_._v(" TCP三次握手 👍")]),_._v(" "),v("p",[v("img",{attrs:{src:"/img/network/tcp-shakes-hands-three-times.png",alt:"tcp-shakes-hands-three-times"}})]),_._v(" "),v("ol",[v("li",[_._v("第一次握手")])]),_._v(" "),v("p",[_._v("客户端向服务端发送连接请求报文段。该报文段的头部中同步SYN=1，确认ACK=0，同时选择一个初始序号seq=x。请求发送后，客户端便进入"),v("strong",[_._v("SYN_SENT")]),_._v("状态。")]),_._v(" "),v("ul",[v("li",[_._v("SYN=1，ACK=0表示该报文段为连接请求报文")]),_._v(" "),v("li",[_._v("x为本次TCP通信的字节流的初始序号")]),_._v(" "),v("li",[_._v("TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号")])]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[_._v("第二次握手")])]),_._v(" "),v("p",[_._v("服务端收到连接请求报文段后，如果同意连接，会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。发送完应答后服务端进入"),v("strong",[_._v("SYN_RECV")]),_._v("状态。")]),_._v(" "),v("ul",[v("li",[_._v("SYN=1，ACK=1表示该报文段为连接同意的应答报文")]),_._v(" "),v("li",[_._v("seq=y表示服务端作为发送者时，发送字节流中的第一个字节序号")]),_._v(" "),v("li",[_._v("ack=x+1表示服务端希望客户端发送的下一个数据报初始序号是从x+1开始")])]),_._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[_._v("第三次握手")])]),_._v(" "),v("p",[_._v("客户端收到服务端连接同意的应答后，还会向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1。")]),_._v(" "),v("p",[_._v("客户端发完这个报文段后便进入"),v("code",[_._v("ESTABLISHED")]),_._v("状态，服务端收到这个应答后也进入"),v("code",[_._v("ESTABLISHED")]),_._v("状态（TCP连接成功），此时连接的建立完成！")]),_._v(" "),v("p",[_._v("三次握手的目的是"),v("strong",[_._v("为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"为什么不是两次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是两次握手"}},[_._v("#")]),_._v(" 为什么不是两次握手？")]),_._v(" "),v("p",[v("strong",[_._v("是为了防止已失效的连接请求报文段突然又传送到了服务端，造成服务端资源的浪费。")])]),_._v(" "),v("blockquote",[v("p",[_._v("在一次TCP连接中，客户端A向服务端B发送连接请求SYN报文段，假如这个报文段没有及时被服务端B接收，而是滞留在网络的某处，于是客户端A超时重传，再次发送请求连接并且顺利与服务端B建立了连接，交换数据后断开连接。")])]),_._v(" "),v("blockquote",[v("p",[_._v("那么滞留在网络中的某处的陈旧报文就变成了失效的连接请求报文。")])]),_._v(" "),v("blockquote",[v("p",[_._v("但如果这个失效的请求SYN报文段，现在又突然传送到了服务端B处，设想这时是使用两次握手而不是三次握手，服务端B就以为客户端A现在建立请求连接，于是服务端B发出确认，新的连接就建立了，服务端B分配资源，等待客户端A传送数据，但客户端A并没有想要建立TCP连接，不会理会服务端B发送的应答，也不会向服务端B传送数据，于是服务端B就白白等待，空耗资源。")])]),_._v(" "),v("blockquote",[v("p",[_._v("使用三次握手可以避免这个情况：服务端B收到客户端A的失效的陈旧SYN报文段，向客户端A发送SYN报文段，选择自己的序号seq=y，确认收到客户端A的SYN报文段，确认号ack=x+1。第三次握手客户端A收到服务器B的SYN报文段后，从确认号就可得知不应理睬这个SYN报文段（因为客户端A现在并没有发送seq=x的报文段）。")])]),_._v(" "),v("blockquote",[v("p",[_._v("这时，客户端A会发送复位报文段，这个复位报文段中，RST=1，ACK=1，确认号ack=y+1。")])]),_._v(" "),v("blockquote",[v("p",[_._v("服务端B收到客户端A的复位报文，就知道不建立TCP连接，不会分配资源等待客户端A发送数据。")])]),_._v(" "),v("blockquote",[v("p",[v("img",{attrs:{src:"/img/network/tcp-shakes-hands-two-times.png",alt:"tcp-shakes-hands-two-times"}})])]),_._v(" "),v("h3",{attrs:{id:"为什么不是四次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是四次握手"}},[_._v("#")]),_._v(" 为什么不是四次握手？")]),_._v(" "),v("p",[_._v("因为三次握手已经能说明握手时的通信是正常的，四次握手、五次握手就显得浪费了。")]),_._v(" "),v("h2",{attrs:{id:"四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手 👍")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("第一次挥手")]),_._v(" ：客户端发送一个 FIN（SEQ=X） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 FIN-WAIT-1 状态。")]),_._v(" "),v("li",[v("strong",[_._v("第二次挥手")]),_._v(" ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包->客户端 。然后，此时服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。")]),_._v(" "),v("li",[v("strong",[_._v("第三次挥手")]),_._v(" ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包->客户端请求关闭连接，然后，服务端进入LAST-ACK状态。")]),_._v(" "),v("li",[v("strong",[_._v("第四次挥手")]),_._v(" ：客户端发送 ACK (SEQ=y+1)标志的数据包->服务端并且进入TIME-WAIT状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。")])]),_._v(" "),v("h3",{attrs:{id:"为什么第四次挥手客户端需要等待-2-msl-报文段最长寿命-时间后才进入-closed-状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么第四次挥手客户端需要等待-2-msl-报文段最长寿命-时间后才进入-closed-状态"}},[_._v("#")]),_._v(" 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？")]),_._v(" "),v("p",[_._v("第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。")]),_._v(" "),v("blockquote",[v("p",[_._v("MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。")])]),_._v(" "),v("h2",{attrs:{id:"tcp粘包、拆包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp粘包、拆包"}},[_._v("#")]),_._v(" TCP粘包、拆包 👍")]),_._v(" "),v("p",[v("code",[_._v("TCP")]),_._v("是面向流，没有界限的一串数据。"),v("code",[_._v("TCP")]),_._v("底层并不了解上层业务数据的具体含义，它会根据"),v("code",[_._v("TCP")]),_._v("缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被"),v("code",[_._v("TCP")]),_._v("拆分成多个包进行发送，也有可能把多个小\n的包封装成一个大的数据包发送，这就是所谓的"),v("code",[_._v("TCP")]),_._v("粘包和拆包问题。")]),_._v(" "),v("h3",{attrs:{id:"为什么会产生粘包和拆包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么会产生粘包和拆包"}},[_._v("#")]),_._v(" 为什么会产生粘包和拆包")]),_._v(" "),v("ol",[v("li",[_._v("要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；")]),_._v(" "),v("li",[_._v("接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；")]),_._v(" "),v("li",[_._v("要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；")]),_._v(" "),v("li",[_._v("待发送数据大于 MSS (最大报文长度),TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度>MSS")])]),_._v(" "),v("h3",{attrs:{id:"解决策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决策略"}},[_._v("#")]),_._v(" 解决策略")]),_._v(" "),v("ol",[v("li",[_._v("发送端将每个数据包封装为固定长度;")]),_._v(" "),v("li",[_._v("在数据尾部增加特殊字符进行分割;")]),_._v(" "),v("li",[_._v("将数据分为两部分，一部分是头部,一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);