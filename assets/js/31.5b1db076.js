(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{308:function(t,a,e){"use strict";e.r(a);var s=e(10),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"aqs-抽象队列同步器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aqs-抽象队列同步器"}},[t._v("#")]),t._v(" AQS 抽象队列同步器 🔨")]),t._v(" "),a("p",[t._v("AQS 的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/concurrent/AQS.awebp",alt:"AQS.awebp"}})]),t._v(" "),a("h2",{attrs:{id:"基本属性-state-双向队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本属性-state-双向队列"}},[t._v("#")]),t._v(" 基本属性：state 双向队列")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//头节点")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//尾节点")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" tail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//状态值")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("AQS的实现依赖内部的同步队列，也就是FIFO的双向队列（双向链表），如果当前线程竞争锁失败，\n那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。\n当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。")]),t._v(" "),a("h2",{attrs:{id:"独占锁-、-共享锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#独占锁-、-共享锁"}},[t._v("#")]),t._v(" 独占锁 、 共享锁")]),t._v(" "),a("ol",[a("li",[t._v("独占锁 ： 同一时间只有一个线程能拿到锁执行，锁的状态只有0和1两种情况\n"),a("ul",[a("li",[t._v("ReentrantLock")])])]),t._v(" "),a("li",[t._v("共享锁 ： 同一时间有多个线程可以拿到锁协同工作，锁的状态大于或等于0\n"),a("ul",[a("li",[t._v("CountDownLatch")])])])]),t._v(" "),a("h2",{attrs:{id:"为什么要用双向链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用双向链表"}},[t._v("#")]),t._v(" 为什么要用双向链表")]),t._v(" "),a("ol",[a("li",[t._v("因为处于锁阻塞的线程允许被中断，被中断的线程是不需要去竞争锁的，但是它仍然存在于双向链表里面。\n在后续的锁竞争中，需要把这个节点从链表里面移除，如果是单向列表，就需要从head节点开始往下逐个便利，效率低下。")])]),t._v(" "),a("h2",{attrs:{id:"semaphore-信号量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#semaphore-信号量"}},[t._v("#")]),t._v(" Semaphore（信号量）")]),t._v(" "),a("p",[a("code",[t._v("synchronized")]),t._v(" 和 "),a("code",[t._v("ReentrantLock")]),t._v(" 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。")]),t._v(" "),a("ol",[a("li",[t._v("Semaphore 与 CountDownLatch 一样，也是共享锁的一种实现。它默认构造 AQS 的 state 为 permits。当执行任务的线程数量超出 permits，那么多余的线程将会被放入阻塞队列 Park,并自旋判断 state 是否大于 0。")]),t._v(" "),a("li",[t._v("只有当 state 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 release() 方法，release() 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。")]),t._v(" "),a("li",[t._v("如此，每次只有最多不超过 permits 数量的线程能自旋成功，便限制了执行任务线程的数量。")])]),t._v(" "),a("h2",{attrs:{id:"countdownlatch-倒计时器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch-倒计时器"}},[t._v("#")]),t._v(" CountDownLatch （倒计时器）")]),t._v(" "),a("p",[t._v("CountDownLatch允许 count 个线程去阻塞等待其他线程。实现流程如下：")]),t._v(" "),a("ol",[a("li",[t._v("CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用 countDown() 方法时,其实使用了tryReleaseShared方法以 CAS 的操作来减少 state,直至 state 为 0 。")]),t._v(" "),a("li",[t._v("当调用 await() 方法的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 方法就会一直阻塞，也就是说 await() 方法之后的语句不会被执行。")]),t._v(" "),a("li",[t._v("然后，CountDownLatch 会自旋 CAS 判断 state == 0，如果 state == 0 的话，就会释放所有等待的线程，await() 方法之后的语句得到执行。")])]),t._v(" "),a("p",[t._v("两种典型的使用场景：")]),t._v(" "),a("ol",[a("li",[t._v("某一线程在开始运行前等待 n 个线程执行完毕\n"),a("ul",[a("li",[t._v("将 CountDownLatch 的计数器初始化为 n （new CountDownLatch(n)），每当一个任务线程执行完毕，就将计数器减 1 （countdownlatch.countDown()），当计数器的值变为 0 时，在 CountDownLatch 上 await() 的线程就会被唤醒。")]),t._v(" "),a("li",[t._v("一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。")])])]),t._v(" "),a("li",[t._v("实现多个线程开始执行任务的最大"),a("strong",[t._v("并行性")]),t._v("。\n"),a("ul",[a("li",[t._v("初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 （new CountDownLatch(1)），多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。")])])])]),t._v(" "),a("h2",{attrs:{id:"cyclicbarrier-循环栅栏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier-循环栅栏"}},[t._v("#")]),t._v(" CyclicBarrier（循环栅栏）")]),t._v(" "),a("p",[t._v("它是一个同步的工具，能够允许一组线程去互相等待直到都到达了屏障，CyclicBarrier对于涉及到固定大小的线程是非常有用的，线程们必须相互等待。该屏障称之为循环屏障，是因为当等待屏障的线程被释放之后，该屏障能循环使用。")]),t._v(" "),a("blockquote",[a("p",[t._v("CountDownLatch 的实现是基于 AQS 的，而 CycliBarrier 是基于 ReentrantLock(ReentrantLock 也属于 AQS 同步器)和 Condition 的。")])]),t._v(" "),a("h2",{attrs:{id:"reentrantlock-可重入锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock-可重入锁"}},[t._v("#")]),t._v(" ReentrantLock（可重入锁）")]),t._v(" "),a("h2",{attrs:{id:"reentrantreadwritelock-可重入读写锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantreadwritelock-可重入读写锁"}},[t._v("#")]),t._v(" ReentrantReadWriteLock（可重入读写锁）")]),t._v(" "),a("h2",{attrs:{id:"参考文档"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[t._v("#")]),t._v(" 参考文档")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6844903732061159437",target:"_blank",rel:"noopener noreferrer"}},[t._v("大白话聊聊Java并发面试问题之谈谈你对AQS的理解？【石杉的架构笔记】"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=n.exports}}]);